Preface:

With the exception of the use of Î£ 
...this is a plain ASCII file, formatted to 80 columns

This file is best viewed in Notepad++
	Use the supplied NPP Language file for syntax highlighting

The macros used to make the headings are also supplied. To use them:
	Find you NPP `settings.xml` file; 
	Paste the supplied macros between the <MACROS>  ... </MACROS> tags

~~~~ ,-----.                                                                    .
~~~ (  WHY  ) ==================================================================.
~~~~ `-----'                                                                    .

Almost every talk I've ever listened to, and almost every lecture I've attended
has started with: "Let's assume there is fully working computer, with a working
operating system, and some working software. Now let's (ab)use that software..."

We all know computers are "made of transistors", but how this is actually
achieved seems to be a secret only known by the silicon alchemists. By the end
of this document you are going to say "is that really all there is to it?"

It is my hope that you will constantly be thinking:
	"Well. Yeah. That's pretty obvious ...if you explain it that way!"
Nothing should seem like a 'quantum leap'.

We're not going to run through this like a maths lecture [*shudders*]
We will take it slowly and surely, in a familiar setting (light switches).
Then tweak that knowledge by replacing the light switches with electronic ones.
Each step is (if I got it right) small, and easy.

It is probably going to be your instinct to try and remember everything the
first time around.  DON'T.  If this is all new to you, there is going to be WAY
too much information to memorise in one sitting.

DON'T PANIC. I will remind you of the relevant bits when the time is right.

If you are just here to "gain an insight", then go at whatever speed you like.

If you are here so you can "properly understand" this, I encourage you to do the
exercises as you go along.  None of them are difficult, they are just carefully
chosen moments where I say:
	"Put the book down for a bit. Take a moment to THINK about this new idea."

If something is unclear to you, tell me; I'm not psychic ;)


~-~~ ,-------------------.    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    <
~-~ (  Table of Contents  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~  <
~-~~ `-------------------'    `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `    <

~~~ (  WHY  ) ==================================================================.

~~~ (  Required Knowledge  ) ===================================================.

    ~-~ The Basic Lightbulb Circuit ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .
        (o) A basic light switch                                                .

	~-~ Physics? Yeah, whatever ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .

	~-~ Counting in Binary  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .
		(o) An 8 bit variable                                                   .
		(o) 57                                                                  .

	~-~ Maths in Binary ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .

	~-~ Superfluous Information ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .

~~~ (  Keep It Simple, Stupid  ) ===============================================.

	(o) A basic light switch                                                    .
	(o) Take out the battery symbol, and just leave the (+) and (-) icons       .
	(o) Rename the battery terminals to [+V] and [Gnd]                          .
	(o) Add some names                                                          .

	~-~ Nomenclature -~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .

	~-~ I/O States  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .

~~~ (  How is this Important?  ) ===============================================.

	(o) Truth Gate                                                              .
	(o) "BUFFER" pocket reference                                               .
	(o) "GATE" pocket reference [template]                                      .

~~~ (  Moar Switches!  ) =======================================================.

	(o) Switches in series                                                      .
	(o) "AND" pocket reference                                                  .

~~~ (  RRRRRRRRRRUNAROUND  ) ===================================================.

	(o) Switches in parallel                                                    .
	(o) "OR" pocket reference                                                   .

~~~ (  Is that it?  ) ==========================================================.

	(o) Inputs in Series with Outputs                                           .

~~~ (  Parallel Outputs  ) =====================================================.

	(o) Switch in parallel with the Bulb                                        .

	~-~ Pick a Direction -~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .
		(o) The "Conventional Current" Metaphor (over-simplified)               .
		(o) "NOT" pocket reference                                              .

	~-~ Kirchhoff, Simply Put -~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

~~~ (  Current Limiting  ) =====================================================.

	~-~ Really. Skip ahead! ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .
		(o) No Current Limiting                                                 .

	~-~ Meanwhile, back in reality  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .

	~-~ Resistance is Critical  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .
		(o) BAD Current Limiting #1                                             .
		(o) BAD Current Limiting #2                                             .
		(o) GOOD Current Limiting                                               .

~~~ (  Serial Switches, Parallel Bulb  ) =======================================.
	(o) Series switches in parallel with the Bulb                               .
	(o) NAND pocket reference                                                   .

~-~ Food for thought -~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~..

~-~ Top Secret Spoiler Alert -~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~..

~~~ (  A Predictable Conclusion  ) =============================================.

	(o) Switches in parallel                                                    .
	(o) Everything in Parallel                                                  .
	(o) NOR pocket reference                                                    .

~~~ (  How much is that now?  ) ================================================.

	(o) "BUFFER" pocket reference                                               .
	(o) "AND" pocket reference                                                  .
	(o) "OR" pocket reference                                                   .
	(o) "NOT" pocket reference                                                  .
	(o) "NAND" pocket reference                                                 .
	(o) "NOR" pocket reference                                                  .

~~~ (  Are we done building gates yet?  ) ======================================.

	(o) Guess the Logic/Truth Table                                             .
	(o) Every possible 2-Input Logic Gate                                       .

~~~ (  Compound Gates  ) =======================================================.

	(o) "A NIMPLY B"  #1                                                        .
	(o) "A NIMPLY B"  #2                                                        .
	(o) "B NIMPLY A"  #1                                                        .
	(o) "B NIMPLY A"  #2                                                        .

~~~ (  Linking Gates to Other Gates  ) =========================================.

	(o) "(N)IMPLY" Logic Tables                                                 .
	(o) "IMPLY" is NIMPLY-NOT                                                   .
	(o) "IMPLY" using an electronic switch                                      .

~~~ (  NIMPLY Gates  ) =========================================================.

	(o) "A NIMPLY B" pocket reference                                           .
	(o) "A IMPLY B" pocket reference                                            .
	(o) "B NIMPLY A" pocket reference                                           .
	(o) "B IMPLY A" pocket reference                                            .
	
~~~ (  Complex Gates  ) ========================================================.

	~-~ Let's Make XOR  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .
		(o) One of the ways to make XOR using (N)AND/(N)OR Logic                .
		(o) OR                                                                  .
		(o) NAND                                                                .
		(o) AND                                                                 .
		(o) XOR circuit (explanatory)                                           .
		(o) XOR circuit (reduced switch count)                                  .
		(o) "XOR" pocket reference                                              .

	~~~ (  Just for completeness  ) ============================================.
		(o) "XNOR" pocket reference                                             .

	~~~ (  NAND gates all the way down  ) ======================================.
		(o) NAND pocket reference (using NAND gates)                            .
		(o) NOT pocket reference (using NAND gates)                             .
		(o) BUFFER pocket reference (using NAND gates)                          .
		(o) AND pocket reference (using NAND gates)                             .
		(o) OR pocket reference (using NAND gates)                              .
		(o) XOR pocket reference (using NAND gates)                             .

	~~~ (  NOR gates all the way down  ) =======================================.

~~~ (  Multiple Inputs  ) ======================================================.

	~-~ Mutli-Input (N)AND Gates ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.
		(o) Multiple Switches in series                                         .

	~-~ Mutli-Input (N)OR Gates  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.
		(o) Multiple Switches in parallel                                       .

	~-~ Mutli-Input X(N)OR Gates ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.
		(o) A XOR B XOR C XOR D : Symbolic Diagram                              .
		(o) A XOR B XOR C XOR D : TL;DR                                         .

~~~ (  WTF is a Transistor?  ) =================================================.

	(o) The "N-Channel Enhancement-Mode MOSFET"                                 .
	(o) FOUR equally valid Circuit Symbols for "N-Channel Enhancement-Mode MOSFE.

	~-~ Nomenclature -~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .
		(o) A MOSFET as a switch                                                .

	~-~ Floating Values ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .

	~-~ Voltage or Current? ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .

~~~ (  THE DICHOTOMY  ) ========================================================.

~~~ (  De-confusing Inverse Logic  ) ===========================================.

	(o) A "BUFFER" using "NOT" Gates                                            .

	~-~ Three Negatives make a Positive  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.
		(o) Logical Equivalents                                                 .
		(o) Proof: ( A  OR  B ) === ( !A  NAND  !B )  ... In English            .
		(o) Proof: ( A  OR  B ) === ( !A  NAND  !B )                            .
		(o) Circuit : ( !A NAND !B ) == ( A OR B )                              .
	~-~ Your Turn -~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

~~~ (  The Summary before the Finale  ) ========================================.

~~~ (  The Gate Finale  ) ======================================================.
	~-~ Three Steps  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

	~-~ Step 1a - "NOT"  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.
	~-~ Step 1b - "NAND" ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.
	~-~ Step 1c - "NOR"  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

	~-~ Step 2 - "AND" and "OR"  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

	~-~ Step 3 - "X(N)OR" -~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

~~~ (  A Human Interface  ) ====================================================.

	~-~ Human Interface  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

	~-~ The Keyboard ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.
		(o) A Random (NOT) Gate                                                 .
		(o) SPDT Input Mechanism                                                .
		(o) SPST Input Mechanism                                                .

	~-~ More input controls  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

	~-~ The Output Display ~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.
		(o) LED with Current Limiting Ressitor                                  .
		(o) Output LED - Wrong                                                  .
		(o) That lightswitch again!                                             .
		(o) Electronic lightswitch                                              .
		(o) Output LED                                                          .

	~-~ An Input Display ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.
		(o) A Random Gate (NOT)                                                 .
		(o) A Random Gate (NOT) with Input LED                                  .
		(o) A Random Gate (NOT) with Input LED (rotated)                        .

~~~ (  AT LONG LAST  ) =========================================================.

~~~ (  Adding up  ) ============================================================.

	(o) Adding two 1-bit numbers to get a 2-bit result                          .
	(o) Truth Table for Half-Adder SUM bit                                      .
	(o) Truth Table for Half-Adder CARRY bit                                    .
	(o) Half Adder pocket reference (with gates)                                .

~~~ (  Adding up longer numbers  ) =============================================.

	(o) The 16 sums you need to know                                            .
	(o) The Edge Cases                                                          .

~~~ (  Full Adder  ) ===========================================================.

	(o) Building a Full Adder (using gates)                                     .
	(o) Rotated Half Adder                                                      .
	(o) Building a Full Adder (using two Half Adders)                           .
	(o) Full Adder (made from Half Adders)                                      .

~~~ (  Brevity is King  ) ======================================================.

	(o) Full Adder pocket reference                                             .

~~~ (  Even ASCII has limitations  ) ===========================================.

~~~ (  Adding up longer numbers  ) =============================================.

	(o) qv. "Required Knowledge : How Binary works"                             .
	(o) A pair of Adders                                                        .
	(o) A pair of indexed Adders                                                .
	(o) 2-bit Full Adder - wroking example                                      .

~~~ (  Adding up Massive numbers  ) ============================================.

	(o) 4-bit Adder : Load the A inputs                                         .
	(o) 4-bit Adder : Load the B inputs                                         .
	(o) 4-bit Adder : Perform the maths                                         .
	(o) 4-bit Adder : Review the result                                         .

~~~ (  Counting in Circles  ) ==================================================.

	(o) 4-bit Counting Circle                                                   .

~~~ (  Consumer Chips  ) =======================================================.

	(o) 4-Bit Adder : Block Diagram                                             .

~~~ (  8-Bit Full Adder  ) =====================================================.

	(o) 8-Bit Adder using two 4-bit Adders                                      .
	(o) 8-bit Adder : Block Diagram (of a theoretical chip)                     .
	(o) N-bit Adder : pocket reference                                          .
~~~ (  Recap  ) ================================================================.

~~~ (  Going Up  ) =============================================================.

	~-~~ (  Incrementor  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~.
		(o) Full Adder : 5 gates                                                .
		(o) Reduce the {XOR}, of the first Half Adder, to {A}                   .
		(o) Reduce the {AND}, of the first Half Adder, to {0}                   .
		(o) Reduce the {OR} to {B}                                              .
		(o) 1-bit Incrementor                                                   .
		(o) N-bit Incrementor                                                   .
		(o) N-bit Incrementor                                                   .
		(o) N-bit Incrementor : Bit-0 Carry.in used as an ENable pin            .

	~-~ Yes, but what have I really ahieved? ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

~~~ (  Something to Take Away  ) ===============================================.

	(o) 4-bit Counting Circle                                                   .
	(o) 4-bit Counting Circle (with negative numbers)                           .

	~-~ (  Complementary My Dear Watson  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~.
		(o) NOT pocket reference                                                .
		(o) 4-bit Inverter                                                      .
		(o) N-bit Incrementor : Bit-0 Carry.in used as an ENable pin            .
		(o) 2's Complement module                                               .
		(o) 2's Complement module Symbol                                        .
		
~~~ (  Take it Away From Me - NOW  ) ===========================================.

	(o) 4-bit Subtactor (using an Adder and 2's module)                         .

~~~ (  The Enabler  ) ==========================================================.
	
	(o) 4-bit Adder and Subtractor                                              .
	(o) 2's Complement module                                                   .
	
	~-~ (  What About the NOT gates?  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~.
		(o) XOR pocket reference                                                .
		(o) 2's Complement module with {Enable} Input                           .
		(o) 2's Complement module with {Enable} Input - Symbol                  .

	~-~ (  All In One Adder/Subtractor  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~.
		(o) Full Adder/Subtractor module                                        .
		(o) Full Adder/Subtractor module - reduced complexity                   .
		(o) Inverter - Symbol                                                   .
		(o) Full Adder/Subtractor module - block diagram                        .
		(o) Adder/Subtractor pocket reference                                   .

~~~ (  Nothing is Free  ) ======================================================.

	~-~ How Long? ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-.

~~~ (  Where are We?  ) ========================================================.

~~~ (  A Challenge For you  ) ==================================================.

~~~ (  Is That The Time?  ) ====================================================.

	(o) Ring Oscillator                                                         .
	(o) Ring Oscillator - Timing Diagam                                         .
	(o) Ring Oscillator - Timing Diagam - Oscilloscope                          .
	(o) Oscillator - Symbol                                                     .

~~~ (  You can't have everything! Where would you keep it?  ) ==================.

	~-~ (  Start Small  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ .
		(o) NOR pocket reference                                                .
		(o) NOR Latch                                                           .

	~-~ (  Sanitise Your Input  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~.
		(o) D-Type Latch - Truth Table                                          .
		(o) D-Type Latch - SET                                                  .
		(o) D-Type Latch - RESET                                                .
		(o) "A NIMPLY B" pocket reference                                       .
		(o) "A NIMPLY B" - Circuit Diagram                                      .
		(o) "A IMPLY B" pocket reference                                        .
		(o) "A IMPLY B" - Circuit Diagram                                       .

	~-~ (  Remember Me  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ .
		(o) D-Type Latch - Logic Diagram                                        .
		(o) D-Type Latch - Logic Diagram (Stanrdardised I/O Naming)             .
		(o) D-Type Latch - Symbol                                               .

	~-~ (  I can has moar RAM?  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~.
		(o) Four 1-bit D-Type Latches with a common Enable pin (diagram)        .
		(o) Four 1-bit D-Type Latches with a common Enable pin (symbol)         .

~~~~ ,--------------------.                                                     .
~~~ (  Required Knowledge  ) ===================================================.
~~~~ `--------------------'                                                     .

All information is given with certain assumptions in place.

I have already assumed you can read
...If you can't, you're going to need a friend to help you!

I will also assume you understand the following:


~-~ The Basic Lightbulb Circuit  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~    .

(o) A basic light switch                                                        .
!                                                                               .
!        ("PtM", Push-to-Make)                 _                                .
!                   switch                    (~)  Lightbulb                    .
!                   __V__                      #                                .
!        ,-----------o o---------------------[###]----------.                   .
!        |                                                  |                   .
!        |                                                  |                   .
!        `-----------------[(+) battery (-)]----------------'                   .
!                                                                               .

	When the button is    {pressed}   / {released}
	the switch will       {close}     / {open}
	the circuit will be   {completed} / {broken}
	electricity will      {flow}      / {not flow}
	and the light will be {on}        / {off}

That is (speaking "conventionally") the electricity is trying to get from the
(+) Terminal of the Battery to the (-) Terminal

If the switch is {open},   there is NO pathway from (+) to (-)
...so electricity CANNOT {flow}

If the switch is {closed}, there  IS a pathway from (+) to (-)
...and that pathway goes via a the lightbulb
...as electricity {flows} through the lightbulb, it will be {on}

If you can understand that, you're gonan be OK.


~-~ Physics? Yeah, whatever ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .

Since inventing electronics, we have "discovered" (decided) that actually it is
"electrons" that move; and they actually move the other way, ie. from (-) to (+)
...although	even this is currently being debated [Apr/2025]

https://www.youtube.com/watch?v=oI_X2cMHNe0

This document is an about electronics, not sub-atomic physics, so we will
use "conventional current" and talk about elctricity moving from (+) to (-)


~-~ Counting in Binary  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .

This can be a difficult concept to get your head around at first.

An EIGHT bit computer handles EIGHT "bits" at a time
Each "bit" can be "1 or 0", aka "on or off", aka "up or down", etc.

However many "bits" you have (8-bit, 16-bit, 32-bit, 64-bit, ...)
	# You start counting from the >RIGHT>

		# The bits are numbered starting from "0"
			# Each time you move <LEFT< you INCREMENT the "bit number"

		# The bits are assigned values starting from "1"
			# Each time you move <LEFT< you DOUBLE the value
			# ie. The value of each "bit" is "2 to the power of bitNumber" (2^b)

(o) An 8 bit variable                                                           .
!                                                                               .
!      7        6        5        4          3        2        1        0       .
!                                                                               .
!	.-----.  .-----.  .-----.  .-----.    .-----.  .-----.  .-----.  .-----.    .
!	| 128 |  |  64 |  |  32 |  |  16 |    |  8  |  |  4  |  |  2  |  |  1  |    .
!	'-----'  '-----'  '-----'  '-----'    '-----'  '-----'  '-----'  '-----'    .
!     2^7      2^6      2^5      2^4        2^3      2^2      2^1      2^0      .
!                                                                               .
!                                                                               .

You can "turn on" (set to "1") none, some, or all of the boxes.

With 8 bits we can count from:  0..255  ...ie. (2^8)-1

If we want to represent the (decimal) value 57 in binary,
  we will need use (32 + 16 + 8 + 1)

(o) 57                                                                          .
!                                                                               .
!                    .-----. .-----.    .-----.                    .-----.      .
!                    |  32 | |  16 |    |  8  |                    |  1  |      .
!   .-----.  .-----. '-----' '-----'    '-----'  .-----.  .-----.  '-----'      .
!   | 128 |  |  64 |                             |  4  |  |  2  |               .
!   '-----'  '-----'                             '-----'  '-----'               .
!                                                                               .
!      0        0       1       1          1        0        0        1         .
!                                                                               .

So if you want to tell a computer you have fifty-seven things,
you do not say "57" (ie. (5*10)+7) ...you say "0011 1001"

It is common practice to write out binary numbers in little groups-of-4
...for reasons that do not matter here     <~ Spoiler: "Hexadeciaml notation" ~>


~-~ Maths in Binary ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .

Don't panic. By "maths" I mean *literally* basic "adding up" and "taking away"!

The biggest number you are going to have to deal with is 15,
so you may have to take your socks off!

You need to understand that these both mean the same thing:

	decimal:    7  +   5  ==  12
	binary:   0111 + 0101 == 1100

You do NOT need to be able to do this in your head.
BUT you DO need to be able to comprehend how this works.

FYI. To this very day, I have this on a sticker on my monitor:

!                    .
!   Dec  Hex  Bin    .
!   ---  ---  ----   .
!     0   0   0000   .
!     1   1   0001   .
!     2   2   0010   .
!     3   3   0011   .
!                    .
!     4   4   0100   .
!     5   5   0101   .
!     6   6   0110   .
!     7   7   0111   .
!                    .
!     8   8   1000   .
!     9   9   1001   .
!    10   A   1010   .
!    11   B   1011   .
!                    .
!    12   C   1100   .
!    13   D   1101   .
!    14   E   1110   .
!    15   F   1111   .
!                    .

~-~ Superfluous Information ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .

You do NOT need to know this (at all).
But as I've just pasted my cheatsheet, it seems polite to explain it!

Hexadecimal is basically used as a short-hand for Binary.

You already know that in normal/decimal maths:  57 == 057 == 0000000057
...Ie. You can put as many 0's on the start of a number as you like -
...    it will NOT change the "value".

The rules here is:
  If the binary number is not a multiple of 4 digit long,
    left-pad it with 0's, so it is.

  Then divide it up in to groups of 4 digits.

        Eg. 11011 -> 00011011 -> 0001'1011
                     ^^^--pad        ^--break

!                                                                               .
! We just worked out Decimal :   57                                             .
!                 == Binary  :   0001'1011    <--.                              .
|                                |__/ |__/       :                              .
|                                |    |          :___ See cheatsheet [above]    .
|                                |,---'          :                              .
|                                ||              :                              .
! So in Hexaadecimal is it   :   1B           <--'                              .
!                    ...aka. : 0x1B                                             .
!                                                                               .


~~~~ ,------------------------.                                                 .
~~~ (  Keep It Simple, Stupid  ) ===============================================.
~~~~ `------------------------'                                                 .

Before we start making things more complicated,
let's make sure we fully understand this light switch circuit.

To start off we will simplify the diagram...

(o) A basic light switch                                                        .
!                                                                               .
!        ("PtM", Push-to-Make)                 _                                .
!                   switch                    (~)  Lightbulb                    .
!                   __V__                      #                                .
!        ,-----------o o---------------------[###]----------.                   .
!        |                                                  |                   .
!        |                                                  |                   .
!        `-----------------[(+) battery (-)]----------------'                   .
!                                                                               .

This circuit is far more complicated than it needs to be, let's simplify it...

(o) Take out the battery symbol, and just leave the (+) and (-) icons           .
!                                              _                                .
!                   switch                    (~)  Lightbulb                    .
!                   __V__                      #                                .
!      (+)-----------o o---------------------[###]----------(-)                 .
!                                                                               .
!                   press    ...............  ON                                .
!                  release   ...............  OFF                               .
!                                                                               .

(o) Rename the battery terminals to [+V] and [Gnd]                              .
!                                              _                                .
!                                             (~)                               .
!                   __V__                      #                                .
!     [+V]-----------o o---------------------[###]----------[Gnd]               .
!                                                                               .

(o) Add some names                                                              .
!                                                                               .
!                    (A) <--- Input            _                                .
!                     |                       (~)                               .
!                   __V__                      #                                .
!     [+V]-----------o o---------------------[###]----------[Gnd]               .
!                                             (Y) <-- Output                    .
!                                                                               .

Inputs at the top; Outputs at the bottom.


~-~ Nomenclature ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

If/When we want more Input switches,
we continue on through the alphabet {A, B, C, ...}

(Basic) Logic Gates only ever have ONE Output:
	"Chip datasheets" seem to refer to this as : {Y}
	"Block diagrams"  seem to refer to this as : {Q}

But there is NO absolute-agreement on ANY I/O pin names!
...They are often named after their intended purpose. Such as:
	# {I}nput
	# {O}utput
	# {S}um
	# {C}arry-flag
	# {D}ata
	# {C}lock
	# {T}rigger
	# ...

...By the roll of a loaded die, I will use: {Y}

~-~ I/O States   ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

We (currently) have TWO "I/O Pins"
    {A}, which is an  "I"nput,
and {Y}, which is our "O"utput

If {A} is {Pressed } we say {A} is {1, +V,  High, True,  On,  Set,   Enabled }
If {A} is {Released} we say {A} is {0, Gnd, Low,  False, Off, Reset, Disabled}

This list of commonly-agreed examples is by-no-means complete!

In fact, you are free to use ANY pair of opposing words or concepts,
for both the Ouput, and/or any additional Inputs.

	A checksum    may be "Good/Bad"
	A soil sensor may be "Wet/Dry"
	A bulb      could be "Glowing/Black"
	A motor     could be "Running/Stopped"
	A fermion   might be "SpinUp/SpinDown"

...you get the idea!


~~~~ ,------------------------.                                                 .
~~~ (  How is this Important?  ) ===============================================.
~~~~ `------------------------'                                                 .

This is *THE* primitive building block of EVERYTHING that follows!

(o) Truth Gate                                                                  .
!                                                                               .
!                    (A)                       _                                .
!                     |                       (~)                               .
!                   __V__                      #                                .
!     [+V]-----------o o---------------------[###]----------[Gnd]               .
!                                             (Y)                               .
!                                                                               .

We might say:
    if   {A} is {pressed},   then   {Y} will be { on }
    if   {A} is { true  },   then   {Y} will be {true}
    if   {A} is {   1   },   then   {Y} will be {  1 }

	...otherwise, {Y} (the light) will be {off/false/0}

This (very simple) logic is (most commonly) called a "BUFFER"
...It has a "Logic/Truth Table" that looks like this:

        .----------------.                   {A}     {Y}  Bulb
        | INPUT | OUTPUT |                 --------  ---  ----
        |   A   |   Y    |          0  =>  released  0V   Off
        +-------+--------+          1  =>  pressed   +V   On
        |   0   |   0    |
        |   1   |  =1=   |      <-- The "=" are simply a visual aid
        '----------------'

To save effort in the long run, let's pick a symbol which means:
    "One switch placed in such a way that
     the Output State MATCHES the Input State"

The symbol for a "BUFFER" is an undecorated triangle

(o) "BUFFER" pocket reference                                                   .
!                                                                               .
!                           (+)---{A}----{Y}---(-)                              .
!       |`.                                                                     .
!       |  `.                                               |   A   |   Y   |   .
!   A---|    `.---Y           BUFFER        ---|>---        +-------+-------+   .
!       |   .'                                              |   0   |   0   |   .
!       | .'                                                |   1   |  =1=  |   .
!       |'                                                                      .
!                   if  (A == 1)  then  {Y=1}  else  {Y=0}                      .
!                                                                               .


(o) "GATE" pocket reference [template]                                          .
!                                                                               .
!                           (+)---  WIRING  ---(-)                              .
!       [   S ]                                                                 .
!       [   Y ]                                             | A | B |   Y   |   .
!   A---[ B M ]---Y           NAME         ---small---      +-------+-------+   .
!       [ I B ]                               symbol        |  TRUTH        |   .
!       [ G O ]                                             |        TABLE  |   .
!       [   L ]                                                                 .
!                          ... coding example...                                .
!                                                                               .


~~~~ ,----------------.                                                         .
~~~ (  Moar Switches!  ) =======================================================.
~~~~ `----------------'                                                         .

Let's add another switch ...in series

"Series" means "one after the other"
...Like a TV "Series", you watch one episode after another.

(o) Switches in series                                                          .
!                                                                               .
!                    (A)       (B)             _                                .
!                     |         |             (~)                               .
!                   __V__     __v__            #                                .
!     [+V]-----------o o-------o o-----------[###]----------[Gnd]               .
!                                             (Y)                               .
!                                                                               .

Now the light will only come on if BOTH buttons are being pressed simultaneously

  if  {A} is {pressed}   AND   {B} is {pressed},  then  {Y} will be { on }
  if  {A} is { true  }   AND   {B} is { true  },  then  {Y} will be {true}
  if  {A} is {   1   }   AND   {B} is {   1   },  then  {Y} will be {  1 }

  ...In ALL (3) other cases, {Y} (the light) will be {off/false/0}

This logic is called an "AND" Gate
...It has a "Logic/Truth Table" that looks like this:

        .----------------.
        | INPUT | OUTPUT |
        | A | B |   Y    |                  {A/B}    {Y}  Bulb
        +----+--+--------+                 --------  ---  ----
        | 0 | 0 |   0    |          0  =>  released  0V   Off
        | 0 | 1 |   0    |          1  =>  pressed   +V   On
        | 1 | 0 |   0    |
        | 1 | 1 |  =1=   |      <-- the only way to turn the light on!
        '----------------'

Let's pick a symbol which means:
	"Two switches organised in such a way that
	The Output state is the logical AND of the (2) Input States"

The symbol for "AND" is a rectangle with one rounded end (the output end)

(o) "AND" pocket reference                                                      .
!                                                                               .
!                       (+)---{A}---{B}---{Y}---(-)                             .
!	    +-----.                                             | A | B |   Y   |   .
!	A---|      \                                __          +----+--+-------+   .
!	    |       }---Y         AND           ---|  \___      | 0 | 0 |   0   |   .
!	B---|      /                            ---|__/         | 0 | 1 |   0   |   .
!	    +-----'                                             | 1 | 0 |   0   |   .
!                                                           | 1 | 1 |  =1=  |   .
!   if  ((A == 1) && (B == 1))  then  {Y=1}  else  {Y=0}                        .
!                                                                               .


~~~~ ,--------------------.                                                     .
~~~ (  RRRRRRRRRRUNAROUND  ) ===================================================.
~~~~ `--------------------'                                                     .

Let's try that again, but this time ...in parallel

"Parallel" means "side-by-side"
...Notice the "ll" in the middle of the word para(ll)el - side-by-side

(o) Switches in parallel                                                        .
!                                                                               .
!                    (B)                                                        .
!                     |                                                         .
!                   __v__                                                       .
!             ,------o o------.                                                 .
!             |               |                                                 .
!             |               |                                                 .
!             |      (A)      |                _                                .
!             |       |       |               (~)                               .
!             |     __V__     |                #                                .
!     [+V]----+------o o------+--------------[###]----------[Gnd]               .
!                                             (Y)                               .
!                                                                               .

Now the light will come on if EITHER or BOTH buttons are being pressed.

  if  {A} is {pressed}   OR   {B} is {pressed},  then  {Y} will be { on }
  if  {A} is { true  }   OR   {B} is { true  },  then  {Y} will be {true}
  if  {A} is {   1   }   OR   {B} is {   1   },  then  {Y} will be {  1 }

  ...In ALL (1) other cases, {Y} (the light) will be {off/false/0}

This logic is called an "OR" Gate
...It has a "Logic/Truth Table" that looks like this:

        .----------------.
        | INPUT | OUTPUT |
        | A | B |   Y    |                  {A/B}    {Y}  Bulb
        +----+--+--------+                 --------  ---  ----
        | 0 | 0 |   0    |          0  =>  released  0V   Off
        | 0 | 1 |  =1=   |          1  =>  pressed   +V   On
        | 1 | 0 |  =1=   |
        | 1 | 1 |  =1=   |
        '----------------'

Let's pick a symbol which means:
	"Two switches organised in such a way that
	The Output state is the logical OR of the (2) Input States"

The "OR" gate symbol is a long (isosceles) triangle with curved sides

(o) "OR" pocket reference                                                       .
!                                                                               .
!                                 +-{B}-+                                       .
!                           (+)---+-{A}-+-{Y}---(-)                             .
!	    +--._                                               | A | B |   Y   |   .
!	A----\   `-.                                _           +----+--+-------+   .
!	      }    ,'---Y         OR            ---\ `.___      | 0 | 0 |   0   |   .
!	B----/  _,'                             ---/_,'         | 0 | 1 |  =1=  |   .
!	    +--'                                                | 1 | 0 |  =1=  |   .
!                                                           | 1 | 1 |  =1=  |   .
!   if  ((A == 1) || (B == 1))  then  {Y=1}  else  {Y=0}                        .
!                                                                               .


~~~~ ,-------------.                                                            .
~~~ (  Is that it?  ) ==========================================================.
~~~~ `-------------'                                                            .

So far we have designed THREE Circuits/Gates

(o) Inputs in Series with Outputs                                               .
!                                                                               .
!   :  Power :       Switch Block       :    Output     : Ground  :        :    .
!   : - - - -:-  - - - - - - - - - - - -:- - - - - - - -:- - - - -:- - - - :    .
!   :        :                          :               :         :        :    .
!   :        :                          :               ;         :        :    .
|   :  [+V]------[Switch]------------------[Lightbulb]-----[Gnd]  : BUFFER :    .
!   :        :                          :               :         :        :    .
!   :        :                          :               :         :        :    .
!   :        :                          :               :         :        :    .
|   :  [+V]------[Switch]-----[Switch]-----[Lightbulb]-----[Gnd]  : AND    :    .
!   :        :                          :               :         :        :    .
!   :        :                          :               :         :        :    .
!   :        :                          :               :         :        :    .
|   :        :      ,--[Switch]--.      :               :         :        :    .
|   :  [+V]---------+            +---------[Lightbulb]-----[Gnd]  : OR     :    .
|   :        :      '--[Switch]--'      :               :         :        :    .
!   :        :                          :               :         :        :    .
!   :        :                          :               :         :        :    .
!                                                                               .

In all three, there is a
	a Switch Block which contains 1 or 2 switches
in Series with
	an Output mechanism (we're currently using a lightbulb)

What happens if we put the switches in "parallel" with the lightbulb?


~~~~ ,------------------.                                                       .
~~~ (  Parallel Outputs  ) =====================================================.
~~~~ `------------------'                                                       .

(o) Switch in parallel with the Bulb                                            .
!                                                                               .
!                    (A)                                                        .
!                     |                                                         .
!                   __V__                                                       .
!             ,------o o------.                                                 .
!             |               |                                                 .
!             |       _       |                                                 .
!             |      (~)      |                                                 .
!             |       #       |                                                 .
!     [+V]----+-----[###]-----+----[Gnd]                                        .
!                    (Y)                                                        .
!                                                                               .

When the switch is {released}, ie. {not-pressed},
the only pathway from +V to Gnd is via the lightbulb, so it will be on.

When the switch is {pressed} the electricity has two pathways to choose from.


~-~ Pick a Direction ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

(o) The "Conventional Current" Metaphor (over-simplified)                       .
!                                                                               .
!         Electricity comes in from [+V] ... and tries to get to [Gnd]          .
!                                                                               .
!    If given a choice of paths, it will take 'the path of least resistance'    .
!                                                                               .

A Light Bulb is actually a really inefficient Resistor.
When powered, a bulb does indeed act as a Resistor.
...But as it 'resists', it gets so hot, it visibly glows!

With a bit of effort you can do it the other way aournd,
and get a resistor to act as a light bulb:
    https://www.youtube.com/watch?v=MUfMPjMAwx8
...it's not a happy ending!

THEREFORE:
When the switch {A} is {pressed/closed},
the electricity has the choice of TWO pathways:
	1) via the highly resistive lightbulb
	2) via the switch, which has (virtually) zero resistance

...It, inevitably, chooses pathway #2, so:

    if  {A} is {pressed},  then  {Y} will be { off }
    if  {A} is { true  },  then  {Y} will be {false}
    if  {A} is {  1    },  then  {Y} will be {  0  }

	...otherwise, {Y} (the light) will be {on/true/1}

This logic is called a "NOT" Gate, or an "INVERTER"
...It has a "Logic/Truth Table" that looks like this:

        .----------------.
        | INPUT | OUTPUT |                   {A}     {Y}  Bulb
        |   A   |   Y    |                 --------  ---  ----
        +-------+--------+          0  =>  released  0V   Off
        |   0   |  =1=   |          1  =>  pressed   +V   On
        |   1   |   0    |
        '----------------'

Let's pick a symbol which means:
    "One switch placed in such a way that
     the Output State OPPOSES the Input State"

The symbol for "NOT" is a tiny circle.

When we ONLY want to "NOT" the Input {A}
we think of it as being an "INVERTED BUFFER" and draw it like this:

(o) "NOT" pocket reference                                                      .
!                                                                               .
!                                 +-{A}-+                                       .
!                           (+)---+-{Y}-+---(-)                                 .
!	    |`.                                                                     .
!	    |  `.  _                                            |   A   |   Y   |   .
!	A---|    `(_)---Y         NOT           ---|>o---       +-------+-------+   .
!	    |   .'                INVERTER                      |   0   |  =1=  |   .
!	    | .'                                                |   1   |   0   |   .
!       |'                                                                      .
!                   if  (A == 1)  then  {Y=0}  else  {Y=1}                      .
!                                                                               .

~-~ Kirchhoff, Simply Put -~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

The "path of least resistance" is an INSANE over-simplifaction.
It is /just enough/ knowledge for us to build a computer.

If you want to delve in to the nitty-gritty of how and why this works,
and be disturbed by my insane over-simplification, please read up on:
	Ohm's Law
	Kirchhoff's Laws
And enjoy some videos from "Simply Put"'s lockdown project:
	https://www.youtube.com/@simplyput2796


~~~~ ,------------------.                                                       .
~~~ (  Current Limiting  ) =====================================================.
~~~~ `------------------'                                                       .

The first time I presented this as a talk, someone [you know who you are] asked
	"What about current limiting resistors?"

There are various equally valid answers to that question:

	1. We're teaching logic, not electronics.
	   ...Shut up - you're not helping!

	2. In this thought experiment we are using an AI controlled, environmental
	   monitoring system, which is connected to a current-limited power supply
	   which can respond nigh-flawlessly, in real-time.
	   ...Don't worry - you're safe!

	3. <siiiggghhh>
	   OK, I'll add a section on current limiting
	   ...BUT : I will tell people:

             !!!         YOU DO NOT //NEED// TO KNOW THIS        !!!
             !!!    FEEL FREE TO SKIP THE REST OF THIS SECTION   !!!


~-~ Really. Skip ahead!  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

(o) No Current Limiting                                                         .
!                                                                               .
!                   __V__                                                       .
!             ,------o o------.                                                 .
!             |               |                                                 .
!     [+V]----+-----[###]-----+----[Gnd]                                        .
!                    (Y)                                                        .
!                                                                               .

Keeping with the "thought experiment" theme,
we are going to need a perfectly spherical cow for this bit.
	https://en.wikipedia.org/wiki/Spherical_cow

First:
   #         Let's assume the wire   has  0 ohms   resistance

   # And let's assume an open switch has infinite  resistance
                 and a closed switch has  0 ohms   resistance

   # And let's assume our power supply is capable of
         delivering an infinite amount of current, instataneously.

   ...Wow, that is one Mother of a Spherical Cow!

Now: When you press the button, you will create a "short circuit"
     ALL the electricity will INSTANTLY move from (+) to (-)
	 ...and the battery (and probably everything else in the circuit)
	    will explode ...spectacularly

~-~ Meanwhile, back in reality   ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

If we (more realistically)
	assume some trivial resistance in the wire and the switch,
	and assume we are using a lithium battery with no charge-protection.

Now: When you press the button.
     The battery ...and maybe the wire ...and maybe the switch
	   are going to (eventually) get VERY hot
	                         (where "VERY" is defined as: "don't touch it")

	 And, if you're lucky, something might melt or explode

        https://www.youtube.com/watch?v=bNNWbm681AI

~-~ Resistance is Critical   ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

Either way, it's not going to end well!

The only way to stop things getting hot is to
  restrict the top speed that the electricity can get from (+) to (-)

We stop things exploding with:  A resistor.

And because we are using our "resistor" to limit the speed of the current,
we call it a "current limiting resistor" ...[how inspired is that?]

We have already shown that a light bulb acts as a (glowing) resistor.

The problem is when we go via the switch-only pathway,
there is no (significant) resistance.

Your first thought might be to try this idea:

(o) BAD Current Limiting #1                                                     .
!                                                                               .
!                   __V__                                                       .
!             ,------o o------[###]-----.                     [WRONG]           .
!             |                         |                                       .
!     [+V]----+-----[###]---------------+----[Gnd]                              .
!                    (Y)                                                        .
!                                                                               .

But this means we end up requiring a resistor for EVERY switch in our gate!
...Suboptimal, to say the least.

How about this:

(o) BAD Current Limiting #2                                                     .
!                                                                               .
!                   __V__                                                       .
!             ,------o o--------.                             [WRONG]           .
!             |                 |                                               .
!            |#|                |                                               .
!            |#|                |                                               .
!            |#|                |                                               .
!             |                 |                                               .
!     [+V]----+-----[###]-------+----[Gnd]                                      .
!                    (Y)                                                        .
!                                                                               .

That solves, the multiple switch problem.

But now, when the path splits, there are two resistors.
...Which way will it go? ...which is the "path of least resistance" now?

Is it really as simple as "*ALL* of the electricity picks one path"
...or is reality actually a lot more complicated that that?
	[bad news: yes]
	[good news: the people who care already know how to work it out]
	[great news: in this guide, it will NEVER become relevant]
	                            ...I did tell you to skip this section!

We could make sure our resistor is smaller than the bulb's resistance

But there are SO MANY reasons (that I will not discuss) as to why:
	This is a BAD IDEA!

Consider this option:

(o) GOOD Current Limiting                                                       .
!                                                                               .
!                               __V__                                           .
!                         ,------o o------.                        [RIGHT]      .
!                         |               |                                     .
!     [+V]--[###]---------+-----[###]-----+----[Gnd]                            .
!             R                  (Y)                                            .
!                                                                               .

This way, we guarantee the path from (+) to (-)
   always has (at least) R "ohms" of resistance
   and the 'pathway decision' is made AFTER there is already a limiter in place.

So, no matter which way the electricity goes,
   nothing (except the lightbulb) will get "hot", "melt", or "explode"

One minor problem: The bulb will be dimmer
...That's the price!
...It's only relevant if you build this in real-life
...But, by that point, we will not be using a "resistive load" as our ouput
...And the whole "lightbulb problem" will have simply disppeared

I did tell you to skip this section.
If you're confused, you've got nobody to blame but yourself!


~~~~ ,--------------------------------.                                         .
~~~ (  Serial Switches, Parallel Bulb  ) =======================================.
~~~~ `--------------------------------'                                         .

I really hope you skipped that last section!

If you ignored my advice, and read it:-
	We had just invented the NOT gate
	by putting the (one) switch in parallel with the bulb...

Next on our list is "AND"

(o) Switches in series                                                          .
!                                                                               .
!                     (A)       (B)             _                               .
!                      |         |             (~)                              .
!                    __V__     __v__            #                               .
!     [+V]------------o o-------o o-----------[###]----------[Gnd]              .
!                                              (Y)                              .
!                                                                               .

...but with the bulb in parallel

(o) Series switches in parallel with the Bulb                                   .
!                                                                               .
!                     (A)       (B)                                             .
!                      |         |                                              .
!                    __V__     __V__                                            .
!              ,------o o-------o o------.                                      .
!              |                         |                                      .
!              |            _            |                                      .
!              |           (~)           |                                      .
!              |            #            |                                      .
!     [+V]--*--+----------[###]----------+----[Gnd]                             .
!           ^              (Y)                                                  .
!           |                                                                   .
!           |                                                                   .
!           `---(insert current limiting resistor here)                         .
!                                                                               .

Now the light will go OFF only if BOTH buttons are being pressed simultaneously

  if  {A} is {pressed}   AND   {B} is {pressed},  then  {Y} will be { off }
  if  {A} is { true  }   AND   {B} is { true  },  then  {Y} will be {false}
  if  {A} is {  1    }   AND   {B} is {  1    },  then  {Y} will be {  0  }

  ...In ALL (3) other cases, {Y} (the light) will be {on/true/1}

This logic is called a "NAND" Gate
...It has a "Logic/Truth Table" that looks like this:

        .----------------.
        | INPUT | OUTPUT |
        | A | B |   Y    |                  {A/B}    {Y}  Bulb
        +----+--+--------+                 --------  ---  ----
        | 0 | 0 |  =1=   |          0  =>  released  0V   Off
        | 0 | 1 |  =1=   |          1  =>  pressed   +V   On
        | 1 | 0 |  =1=   |
        | 1 | 1 |   0    |      <-- the only way to turn the light OFF!
        '----------------'

Let's pick a symbol which means:
	"Two switches organised in such a way that
	 The Output state is the inverted logical AND
	                         \______(NAND)______/  of the (2) Input States"

The symbol for "NAND" is an AND with a NOT (tiny circle) after it

(o) NAND pocket reference                                                       .
!                                                                               .
!                              +-{A}---{B}-+                                    .
!                        (+)---+----{Y}----+---(-)                              .
!	    +-----.                                             | A | B |   Y   |   .
!	A---|      \  _                             __          +----+--+-------+   .
!	    |       }(_)---Y      NAND          ---|  \o___     | 0 | 0 |  =1=  |   .
!	B---|      /                            ---|__/         | 0 | 1 |  =1=  |   .
!	    +-----'                                             | 1 | 0 |  =1=  |   .
!                                                           | 1 | 1 |   0   |   .
!                                                                               .
!   if  ((A == 1) && (B == 1))  then  {Y=0}  else  {Y=1}                        .
!                                        ^------------------ NOT                .
!                                                                               .


~-~ Food for thought ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

Although "NAND" is "AND" with an "N" put at the start of the word,
Notice (from the symbol) that the NOT-event happens to the *OUTPUT*
...I guess "ANDN" was just too tricky to pronounce "\_o_/"

What it means is, we
	perform the AND operation as we normally would
	but just before we give the result we NOT/INVERT it, so that
		"True"  is represented by "0", and
		"False" is represented by "1"

This is (to most English speaking people) VERY confusing
	"if you have tea NAND milk ...go to the shop"
	...that request hurts my brain.

However, it can be rephrased as
	"if you have tea NAND milk ...go to the shop"
					 |_______________
					                 Vvv
	"if you have tea  AND milk ...do NOT go to the shop"
	...which makes a LOT more sense to me.

Even better would be:
	"if you DON'T have tea, OR you DON'T have milk ...go to the shop"
	...which is probably how I would personally phrase it

All three of these give the SAME result
	"    tea NAND     milk  ->      shop"      T NAND  M -->  S
	"    tea  AND     milk  ->  NOT-shop"      T  AND  M --> !S
	"NOT-tea  OR  NOT-milk  ->      shop"     !T  OR  !M -->  S

We can generalise this as:  ( A  NAND  B )  ===  ( !A  OR  !B )
                Curiously:  ( A  NOR   B )  ===  ( !A  AND !B )   also works!

~-~ Top Secret Spoiler Alert ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

There are loads of these useful similies/"equivalences"

  00:  ( A NAND B )  ===  !( !A NOR  !B )
  01:  ( A NAND B )  ===   ( !A  OR  !B )    notice: You always need an
  10:  ( A  AND B )  ===   ( !A NOR  !B )            ODD number of NOTs {N, !}
  11:  ( A  AND B )  ===  !( !A  OR  !B )

  These allow us to create "(N)AND" gates from "(N)OR" gates
  ...which has more uses than you might realise!

You can even swap all the AND's and OR's

  00:  ( A NOR B )  ===  !( !A NAND  !B )
  01:  ( A NOR B )  ===   ( !A  AND  !B )    notice: You always need an
  10:  ( A  OR B )  ===   ( !A NAND  !B )            ODD number of NOTs {N, !}
  11:  ( A  OR B )  ===  !( !A  AND  !B )

  Thes allow us to create "(N)OR" gates from "(N)AND" gates

There's more:

       !A  ===  (A NOR A)  === (A NAND A)

  These allow us to create "NOT" gates from either "NAND" OR "NOR" gates

They are, for you, for now, and for the most-part, a mathematical curiosity
...Don't bother trying to remember them!
...To build a computer you need to understand, at most, two of them!
...And when the time comes, I will discuss those two a little more.

For now, we've got one gate left to try in parallel...


~~~~ ,--------------------------.                                               .
~~~ (  A Predictable Conclusion  ) =============================================.
~~~~ `--------------------------'                                               .

It probably getting quite predictable by now...

If we put the bulb in-parallel, instead of in-series,
and all the {on}'s become {off}'s ...and vice versa.

But, for completeness, lets draw out the "NOR" gate

(o) Switches in parallel                                                        .
!                                                                               .
!                    (B)                                                        .
!                     |                                                         .
!                   __v__                                                       .
!             ,------o o------.                                                 .
!             |               |                                                 .
!             |      (A)      |                _                                .
!             |       |       |               (~)                               .
!             |     __V__     |                #                                .
!     [+V]----+------o o------+--------------[###]----------[Gnd]               .
!                                             (Y)                               .
!                                                                               .

(o) Everything in Parallel                                                      .
!                                                                               .
!                     (B)                                                       .
!                      |                                                        .
!                    __V__                                                      .
!              ,------o o------.                                                .
!              |               |                                                .
!              |      (A)      |                                                .
!              |       |       |                                                .
!              |     __V__     |                                                .
!              +------o o------+                                                .
!              |               |                                                .
!              |       _       |                                                .
!              |      (~)      |                                                .
!              |       #       |                                                .
!     [+V]--*--+-----[###]-----+----[Gnd]                                       .
!                     (Y)                                                       .
!                                                                               .

Now the light will go OFF if EITHER or BOTH buttons are being pressed

  if  {A} is {pressed}   OR   {B} is {pressed},  then  {Y} will be { off }
  if  {A} is { true  }   OR   {B} is { true  },  then  {Y} will be {false}
  if  {A} is {  1    }   OR   {B} is {  1    },  then  {Y} will be {  0  }

  ...In ALL (3) other cases, {Y} (the light) will be {on/true/1}

This logic is called a "NOR" Gate
...It has a "Logic/Truth Table" that looks like this:

        .----------------.
        | INPUT | OUTPUT |
        | A | B |   Y    |                  {A/B}    {Y}  Bulb
        +----+--+--------+                 --------  ---  ----
        | 0 | 0 |  =1=   |          0  =>  released  0V   Off
        | 0 | 1 |   0    |          1  =>  pressed   +V   On
        | 1 | 0 |   0    |
        | 1 | 1 |   0    |
        '----------------'

Let's pick a symbol which means:
	"Two switches organised in such a way that
	 The Output state is the inverted logical OR
	                         \______(NOR)______/  of the (2) Input States"

The symbol for "NOR" is an OR with a NOT (tiny circle) after it

(o) NOR pocket reference                                                        .
!                                                                               .
!                                 +-{B}-+                                       .
!                                 +-{A}-+                                       .
!                           (+)---+-{Y}-+---(-)                                 .
!	    +--._                                               | A | B |   Y   |   .
!	A----\   `-.  _                             _           +----+--+-------+   .
!	      }    ,'(_)---Y      NOR           ---\ `.o___     | 0 | 0 |  =1=  |   .
!	B----/  _,'                             ---/_,'         | 0 | 1 |   0   |   .
!	    +--'                                                | 1 | 0 |   0   |   .
!                                                           | 1 | 1 |   0   |   .
!                                                                               .
!   if  ((A == 1) || (B == 1))  then  {Y=0}  else  {Y=1}                        .
!                                        ^------------------ NOT                .
!                                                                               .


~~~~ ,-----------------------.                                                  .
~~~ (  How much is that now?  ) ================================================.
~~~~ `-----------------------'                                                  .

Let's review all the Logic Gates we have made:

(o) BUFFER pocket reference                                                     .
!                                                                               .
!                           (+)---{A}----{Y}---(-)                              .
!       |`.                                                                     .
!       |  `.                                               |   A   |   Y   |   .
!   A---|    `.---Y           BUFFER        ---|>---        +-------+-------+   .
!       |   .'                                              |   0   |   0   |   .
!       | .'                                                |   1   |  =1=  |   .
!       |'                                                                      .
!                   if  (A == 1)  then  {Y=1}  else  {Y=0}                      .
!                                                                               .

(o) "AND" pocket reference                                                      .
!                                                                               .
!                       (+)---{A}---{B}---{Y}---(-)                             .
!	    +-----.                                             | A | B |   Y   |   .
!	A---|      \                                __          +----+--+-------+   .
!	    |       }---Y         AND           ---|  \___      | 0 | 0 |   0   |   .
!	B---|      /                            ---|__/         | 0 | 1 |   0   |   .
!	    +-----'                                             | 1 | 0 |   0   |   .
!                                                           | 1 | 1 |  =1=  |   .
!   if  ((A == 1) && (B == 1))  then  {Y=1}  else  {Y=0}                        .
!                                                                               .

(o) OR pocket reference                                                         .
!                                                                               .
!                                 +-{B}-+                                       .
!                           (+)---+-{A}-+-{Y}---(-)                             .
!	    +--._                                               | A | B |   Y   |   .
!	A----\   `-.                                _           +----+--+-------+   .
!	      }    ,'---Y         OR            ---\ `.___      | 0 | 0 |   0   |   .
!	B----/  _,'                             ---/_,'         | 0 | 1 |  =1=  |   .
!	    +--'                                                | 1 | 0 |  =1=  |   .
!                                                           | 1 | 1 |  =1=  |   .
!   if  ((A == 1) || (B == 1))  then  {Y=1}  else  {Y=0}                        .
!                                                                               .

(o) NOT pocket reference                                                        .
!                                                                               .
!                                 +-{A}-+                                       .
!                           (+)---+-{Y}-+---(-)                                 .
!	    |`.                                                                     .
!	    |  `.  _                                            |   A   |   Y   |   .
!	A---|    `(_)---Y         NOT           ---|>o---       +-------+-------+   .
!	    |   .'                INVERTER                      |   0   |  =1=  |   .
!	    | .'                                                |   1   |   0   |   .
!       |'                                                                      .
!                   if  (A == 1)  then  {Y=0}  else  {Y=1}                      .
!                                                                               .

(o) NAND pocket reference                                                       .
!                                                                               .
!                              +-{A}---{B}-+                                    .
!                        (+)---+----{Y}----+---(-)                              .
!	    +-----.                                             | A | B |   Y   |   .
!	A---|      \  _                             __          +----+--+-------+   .
!	    |       }(_)---Y      NAND          ---|  \o___     | 0 | 0 |  =1=  |   .
!	B---|      /                            ---|__/         | 0 | 1 |  =1=  |   .
!	    +-----'                                             | 1 | 0 |  =1=  |   .
!                                                           | 1 | 1 |   0   |   .
!                                                                               .
!   if  ((A == 1) && (B == 1))  then  {Y=0}  else  {Y=1}                        .
!                                        ^------------------ NOT                .
!                                                                               .

(o) NOR pocket reference                                                        .
!                                                                               .
!                                 +-{B}-+                                       .
!                                 +-{A}-+                                       .
!                           (+)---+-{Y}-+---(-)                                 .
!	    +--._                                               | A | B |   Y   |   .
!	A----\   `-.  _                             _           +----+--+-------+   .
!	      }    ,'(_)---Y      NOR           ---\ `.o___     | 0 | 0 |  =1=  |   .
!	B----/  _,'                             ---/_,'         | 0 | 1 |   0   |   .
!	    +--'                                                | 1 | 0 |   0   |   .
!                                                           | 1 | 1 |   0   |   .
!                                                                               .
!   if  ((A == 1) || (B == 1))  then  {Y=0}  else  {Y=1}                        .
!                                        ^------------------ NOT                .
!                                                                               .


~~~~ ,---------------------------------.                                        .
~~~ (  Are we done building gates yet?  ) ======================================.
~~~~ `---------------------------------'                                        .

Not quite ...We need to make ONE more                 <~ Spoiler Alert: "XOR" ~>

And to do that we need to learn ONE new principle     <~ Spoiler Alert:       ~>
                                           <~ "Sending the output of one gate ~>
                                           <~        to the input of another" ~>

Other gates do theoretically exist,
Eg. What are these truth tables called?

(o) Guess the Logic/Truth Table                                                 .
!                                                                               .
!	          | A | B |   Y   |             | A | B |   Y   |                   .
!	          +----+--+-------+             +----+--+-------+                   .
!	          | 0 | 0 |   0   |             | 0 | 0 |   0   |                   .
!	          | 0 | 1 |   0   |             | 0 | 1 |   0   |                   .
!	          | 1 | 0 |  =1=  |             | 1 | 0 |  =1=  |                   .
!	          | 1 | 1 |  =1=  |             | 1 | 1 |   0   |                   .
!                                                                               .

Let's draw up the table of all (16) possible (2-input) gates:

(o) Every possible 2-Input Logic Gate                                           .
!                                                                               .
! ,---------------------------- Output Logic Symbol -----------------------.    .
! | Input ||         _       _             : _   _   _       _       _     |    .
! | A : B || 0 : & : > : a : < : b : ^ : | : | : ^ : b : < : a : > : & : 1 |    .
! |-------------------------------------------------------------------------    .
! | 0 | 0 || 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |=1=|=1=|=1=|=1=|=1=|=1=|=1=|=1=|    .
! | 0 | 1 || 0 | 0 | 0 | 0 |=1=|=1=|=1=|=1=| 0 | 0 | 0 | 0 |=1=|=1=|=1=|=1=|    .
! | 1 | 0 || 0 | 0 |=1=|=1=| 0 | 0 |=1=|=1=| 0 | 0 |=1=|=1=| 0 | 0 |=1=|=1=|    .
! | 1 | 1 || 0 |=1=| 0 |=1=| 0 |=1=| 0 |=1=| 0 |=1=| 0 |=1=| 0 |=1=| 0 |=1=|    .
! `------------------------------------------------------------------------'    .
|            0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
!            ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^      .
!     ZERO --'   |   |   |   |   |   |   |   |   |   |   |   |   |   |   `-- ONE.
!          AND --'   |   |   |   |   |   |   |   |   |   |   |   |   `-- NAND   .
!       A NIMPLY B --'   |   |   |   |   |   |   |   |   |   |   `-- A IMPLY B  .
!                  {A} --'   |   |   |   |   |   |   |   |   `-- NOT-{A}        .
!               B NIMPLY A --'   |   |   |   |   |   |   `-- B IMPLY A          .
!                          {A} --'   |   |   |   |   `-- NOT-{A}                .
!                              XOR --'   |   |   `-- XNOR                       .
!                                   OR --'   `-- NOR                            .
!                                                                               .

...And then write it out in a way which is readable:

   1 : 0001 : A AND  B   - if A=1 AND B=1 -> 1  .. AND
  14 : 1110 : A NAND B   - if A=1 AND B=1 -> 0  .. NAND

   7 : 0111 : A OR  B    - if A=1 OR  B=1 -> 1  .. OR
   8 : 1000 : A NOR B    - if A=1 OR  B=1 -> 0  .. NOR

  12 : 1100 : NOT-A      - if A=1         -> 0  .. NOT A
  10 : 1010 : NOT-B      - if B=1         -> 0  .. NOT B

   3 : 0011 : A          - if A=1         -> 1  .. BUFFER A  .. superfluous
   5 : 0101 : B          - if B=1         -> 1  .. BUFFER B  .. superfluous
   0 : 0000 : ZERO       - Always         -> 0  .. superfluous, use {Gnd}
  15 : 1111 : ONE        - Always         -> 1  .. superfluous, use {+V}

   2 : 0010 : A NIMPLY B - if A=0 OR  B=1 -> 0  .. The 4 "implication" Gates are
  14 : 1101 : A IMPLY  B - if A=0 OR  B=1 -> 1  .. used in genetic/DNA circuits.
   4 : 0100 : B NIMPLY A - if B=0 OR  A=1 -> 0  .. Rare in computer science,
  11 : 1011 : B IMPLY  A - if B=0 OR  A=1 -> 1  .. but pose a nice seque [below]

   6 : 0110 : A XOR  B   - if A != B      -> 1  .. XOR  looks for "differences"
   9 : 1001 : A XNOR B   - if A != B      -> 0  .. XNOR looks for "similarities"

# We've done the first 6 {AND, NAND, OR, NOR, BUFFER-A, NOT-A}
# We'll ignore the next 4 {BUFFER-B, NOT-B, ZERO, ONE} as mathematical anomalies
# We'll skip the next 4 "Implication" Gates ... We just don't need them!
# That leaves the 2 "Difference" Gates {XOR, XNOR}

We are going to NEED "XOR"
...And to do that, we are going to need to start linking gates together


~~~~ ,----------------.                                                         .
~~~ (  Compound Gates  ) =======================================================.
~~~~ `----------------'                                                         .

Before we tackle the "XOR" problem (and we will),
...let's look closer at the Series/Parallel combinations we missed!

(o) A NIMPLY B  #1                                                              .
!                                                                               .
!                            ,----[SwitchB]----.            | A | B |   Y   |   .
!                            |                 |            +----+--+-------+   .
!   [+V]--*------[SwitchA]---+---[LightBulb]---+----[Gnd]   | 0 | 0 |   0   |   .
!                                                           | 0 | 1 |   0   |   .
!                                                           | 1 | 0 |   1   |   .
!                      A NIMPLY B                           | 1 | 1 |   0   |   .
!                                                                               .

(o) A NIMPLY B  #2                                                              .
!                                                                               .
!            ,------------[SwitchB]------------.            | A | B |   Y   |   .
!            |                                 |            +----+--+-------+   .
!   [+V]--*--+----[SwitchA]-----[LightBulb]----+----[Gnd]   | 0 | 0 |   0   |   .
!                                                           | 0 | 1 |   0   |   .
!                                                           | 1 | 0 |   1   |   .
!                      A NIMPLY B                           | 1 | 1 |   0   |   .
!                                                                               .

(o) B NIMPLY A  #1                                                              .
!                                                                               .
!            ,---[SwitchA]---.                              | A | B |   Y   |   .
!            |               |                              +----+--+-------+   .
!   [+V]--*--+--[LightBulb]--+----[SwitchB]---------[Gnd]   | 0 | 0 |   0   |   .
!                                                           | 0 | 1 |   1   |   .
!                                                           | 1 | 0 |   0   |   .
!                      B NIMPLY A                           | 1 | 1 |   0   |   .
!                                                                               .

(o) B NIMPLY A  #2                                                              .
!                                                                               .
!            ,------------[SwitchA]------------.            | A | B |   Y   |   .
!            |                                 |            +----+--+-------+   .
!   [+V]--*--+--[LightBulb]-------[SwitchB]----+----[Gnd]   | 0 | 0 |   0   |   .
!                                                           | 0 | 1 |   1   |   .
!                                                           | 1 | 0 |   0   |   .
!                      B NIMPLY A                           | 1 | 1 |   0   |   .
!                                                                               .

Notice:
	# We have TWO  ways to make EACH   "NIMPLY" gate {A-NIMPLY-B, B-NIMPLY-A}
	# We have ZERO ways to make EITHER "IMPLY"  gate {A-IMPLY-B,  B-IMPLY-A }

Unless you dabble with Genetic Programming, you're unlikely to recognise these.

You WILL have used them lots ...but in a different form:

	if (raining = true ) AND (unbrella  = false) then GetWet(1)  [ StayDry(0) ]
	if      raining     NIMPLY     umbrella      then GetWet(1)  [ StayDry(0) ]

	if (raining = false)  OR (unbrella  = true ) then GetWet(0)  [ StayDry(1) ]
	if      raining     IMPLY      umbrella      then GetWet(0)  [ StayDry(1) ]

Fo us, they will serve as the PERFECT (trivial) introduction to demonstrate:...


~~~~ ,------------------------------.                                           .
~~~ (  Linking Gates to Other Gates  ) =========================================.
~~~~ `------------------------------'                                           .

To make the "IMPLY" gates, we need to take the Ouput from
one of the related "NIMPLY" gates, and pass it through a "NOT" gate.

These are directly equivalent:    (A,B)-->---------[IMPLY]------>--(Y)
                                  (A,B)-->--[NIMPLY]-->--[NOT]-->--(Y)

(o) "(N)IMPLY" Logic Tables                                                     .
!                                     .                                         .
!  (A->B)                             .  (B->A)                                 .
!           Q = A NIMPLY B            .            Q = B NIMPLY A               .
!           Y = A  IMPLY B            .            Y = B  IMPLY A               .
!                                     .                                         .
|                                     .                                         .
!                                     .                                         .
!      | A | B |   Q   |   Y   |      .       | A | B |   Q   |   Y   |         .
!      +----+--+-------+-------+      .       +----+--+-------+-------+         .
!      | 0 | 0 |   0   |  =1=  |      .       | 0 | 0 |   0   |  =1=  |         .
!      | 0 | 1 |   0   |  =1=  |      .       | 0 | 1 |  =1=  |   0   |         .
!      | 1 | 0 |  =1=  |   0   |      .       | 1 | 0 |   0   |  =1=  |         .
!      | 1 | 1 |   0   |  =1=  |      .       | 1 | 1 |   0   |  =1=  |         .
!                                     .                                         .
|        |   |     ^       ^          .         |   |     ^       ^             .
|        |   |     |       |          .         |   |     |       |             .
!        v   v     |       |          .         v   v     |       |             .
!       [NIMPLY]->-+-> NOT-'          .        [NIMPLY]->-+-> NOT-'             .
!                                     .                                         .

We are currently using a Lightbulb as the Output Device of our gate(s).

If we want to use that Output as the Input to a second (or subsequent) gate,
we will need to use a switch that responds to Light (rather than being fingered)

And, in case you're thinking: "This lightbulb metaphor is growing thin"
...This is EXACTLY how an "OptoIsolator" works!

	https://circuitspedia.com/optocoupler-opto-coupler-opto-isolator-working-and-uses/

As a demonstration of linking gates, let's do {A IMPLY B}

(o) "IMPLY" is NIMPLY-NOT                                                       .
!                                                                               .
!    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .     .
!    .                                                                    .     .
!       A NIMPLY B                              (B)                             .
!    .                                           |                        .     .
!                                              __v__                            .
!    .                                   ,------o o------.                .     .
!                      (A)               |               |                      .
!    .                  |                |               |                .     .
!                     __V__              |               |                      .
!    .  [+V]--*--------o o---------------+-----[###]-----+----[Gnd]       .     .
!                                                #                              .
!    .                                          (Q)                       .     .
!                                              '...`                            .
!    .  .  .  .  .  .  .  .  .  .  .  .  .  .  ' ' ` .  .  .  .  .  .  .  .     .
!                                             \     /                           .
!                      .  NOT                  \_V_/                      .     .
!                                            [Sensor]                           .
!                      .                         |                        .     .
!                                              __v__                            .
!                      .                 ,------o o------.                .     .
!                                        |               |                      .
!                      .                 |               |                .     .
!                                        |               |                      .
!                      .   [+V]--*-------+-----[###]-----+----[Gnd]       .     .
!                                                #                              .
!                      .                        (Y)                       .     .
!                                                                               .
!                      .  .  .  .  .  .  .  .  . |.  .  .  .  .  .  .  .  .     .
!                                                |                              .
!                                               (Y) = A IMPLY B                 .
!                                                                               .

You really can use light sources, and light sensors if you want.
    If the output were a motor  , you might use a dynamo     as a sensor.
    If the output were a heater , you might use a thermostat as a sensor.
    If the output were a speaker, you could use a microphone as a sensor.
...You get the idea

We can connect gates together with pretty much any crazy idea we can dream up!

Ideally, we'd like to just:
   take the wire that normally carries power to the lightbulb
   and redirect it to the Input of the next gate
   ...by using some kind of "electronic switch"

(o) "IMPLY" using an electronic switch                                          .
!                                                                               .
!    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .     .
!                                                                               .
!    .  A NIMPLY B                              (B)                       .     .
!                                                |                              .
!    .                                         __v__                      .     .
!                                        ,------o o------.                      .
!    .                 (A)               |               |                .     .
!                       |                |               |                      .
!    .                __V__              |               |                .     .
!       [+V]--*--------o o---------------+-----.    -----+----[Gnd]             .
!    .                                          `.                        .     .
!                                                |                              .
!    .  .  .  .  .  .  .  .  .  .  .  .  .  .  . |.  .  .  .  .  .  .  .  .     .
!                                                |     Electronic switch        .
!                      .  NOT                    |    /    +V = pressed   .     .
!                                                |  |/    Gnd = released        .
!                      .                       __V__                      .     .
!                                              |   |                            .
!                      .                 ,-----'   '-----.                .     .
!                                        |               |                      .
!                      .   [+V]--*-------+-----[###]-----+----[Gnd]       .     .
!                                                #                              .
!                      .                        (_)                       .     .
!                                                                               .
!                      .  .  .  .  .  .  .  .  . |.  .  .  .  .  .  .  .  .     .
!                                                |                              .
!                                               (Y) = A IMPLY B                 .
!                                                                               .


~~~~ ,--------------.                                                           .
~~~ (  NIMPLY Gates  ) =========================================================.
~~~~ `--------------'                                                           .

For completeness, here are the pocket references for the 4 NIMPLY Gates

(o) "A NIMPLY B" pocket reference                                               .
!                                                                               .
!                                   +--{B}--+                                   .
!                        (+)---{A}--+--{Y}--+---(-)                             .
!	       +-----.                                          | A | B |   Y   |   .
!	A------|      \                             __          +----+--+-------+   .
!	     _ |       }---Y    A AND NOT(B)    ---|  \___      | 0 | 0 |   0   |   .
!	B---(_)|      /         A NIMPLY B      --o|__/         | 0 | 1 |   0   |   .
!	       +-----'                                          | 1 | 0 |  =1=  |   .
!                                                           | 1 | 1 |   0   |   .
!   if  ((A == 1) && (B == 0))  then  {Y=1}  else  {Y=0}                        .
!                                                                               .

(o) "A IMPLY B" pocket reference                                                .
!                                                                               .
!	     _ +--._                                            | A | B |   Y   |   .
!	A---(_)-\   `-.                             _           +----+--+-------+   .
!	         }    ,'---Y    NOT(A) OR B     --o\ `.___      | 0 | 0 |  =1=  |   .
!	B-------/  _,'           A IMPLY B      ---/_,'         | 0 | 1 |  =1=  |   .
!	       +--'                                             | 1 | 0 |   0   |   .
!                                                           | 1 | 1 |  =1=  |   .
!   if  ((A == 0) || (B == 1))  then  {Y=1}  else  {Y=0}                        .
!                                                                               .

(o) "B NIMPLY A" pocket reference                                               .
!                                                                               .
!                                   +--{A}--+                                   .
!                        (+)---{B}--+--{Y}--+---(-)                             .
!	     _ +-----.                                          | A | B |   Y   |   .
!	A---(_)|      \                             __          +----+--+-------+   .
!	       |       }---Y    NOT(A) AND B    --o|  \___      | 0 | 0 |   0   |   .
!	B------|      /         B NIMPLY A      ---|__/         | 0 | 1 |  =1=  |   .
!	       +-----'                                          | 1 | 0 |   0   |   .
!                                                           | 1 | 1 |   0   |   .
!   if  ((A == 0) && (B == 1))  then  {Y=1}  else  {Y=0}                        .
!                                                                               .

(o) "B IMPLY A" pocket reference                                                .
!                                                                               .
!	       +--._                                            | A | B |   Y   |   .
!	A-------\   `-.                             _           +----+--+-------+   .
!	     _   }    ,'---Y    NOT(B) OR A     ---\ `.___      | 0 | 0 |  =1=  |   .
!	B---(_)-/  _,'           B IMPLY A      --o/_,'         | 0 | 1 |   0   |   .
!	       +--'                                             | 1 | 0 |  =1=  |   .
!                                                           | 1 | 1 |  =1=  |   .
!   if  ((A == 1) || (B == 0))  then  {Y=1}  else  {Y=0}                        .
!                                                                               .


~~~~ ,---------------.                                                          .
~~~ (  Complex Gates  ) ========================================================.
~~~~ `---------------'                                                          .

Last on our list is: "XOR" ...and it's opposite: "XNOR".

Some (weird) people [I'm looking at you Rockwell] use {EOR} and {ENOR}, I don't!

{XOR} looks for differences - ie. {A} and {B} must be DIFFERENT
{XNOR} is the opposite      - ie. {A} and {B} must be THE SAME  [NOT different]

...As always the "N" is added in a way that is easy to say out loud
   the "NOT" event (effectively) still happens to the Output.

As you can imagine, these two skills
	Are these (2) things different
	Are these (2) things the same
...are VERY important skills for a computer.

The {XOR} (aka. {EOR}) gate is not immediately obvious.
...Once it has been explained, it will make perfect sense.
...But you're probably not going to guess it!

The output of an {XOR} is
	True if (EXclusively) *either* {A} *OR* {B} is True, but *NOT BOTH*
	Ie. True if {A} and {B} are different

The "XOR" gate has a "Logic/Truth Table" that looks like this:
	.----------------.
	|  XOR  | OUTPUT |
	| A | B |   Y    |
	+----+--+--------+
	| 0 | 0 |   0    |
	| 0 | 1 |  =1=   |     XOR : A != B
	| 1 | 0 |  =1=   |
	| 1 | 1 |   0    |
	'----------------'

If you fancy a puzzle, feel free to pause here and work out a way to do it.
There are many (many) ways to do it ...Today: If it works, You Win!

.
.
.

~-~ Let's Make XOR   ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

Let's review some familiar Truth Tables:

	 ,----- To help this explanation, I've numbered each row
	 |
	 |  .----------------.
	 |  |  OR   | OUTPUT |
	 V  | A | B |   Y    |
	    +----+--+--------+
	{0} | 0 | 0 |   0    |
	    |   |   |        |
	{1} | 0 | 1 |  =1=   | <--,
	{2} | 1 | 0 |  =1=   | <--+-- OR  : Any one of these three
	{3} | 1 | 1 |  =1=   | <--'
	    '----------------'

	    .----------------.
	    |  NAND | OUTPUT |
	    | A | B |   Y    |
	    +----+--+--------+
	{0} | 0 | 0 |  =1=   | <--,
	{1} | 0 | 1 |  =1=   | <--+-- NAND: Any one of these three
	{2} | 1 | 0 |  =1=   | <--'
	    |   |   |        |
	{3} | 1 | 1 |   0    |
	    '----------------'

	    .----------------.
	    |  XOR  | OUTPUT |
	    | A | B |   Y    |
	    +----+--+--------+
	{0} | 0 | 0 |   0    |
	    |   |   |        |
	{1} | 0 | 1 |  =1=   | <--,__ XOR  : Either of these two
	{2} | 1 | 0 |  =1=   | <--'
	    |   |   |        |
	{3} | 1 | 1 |   0    |
	    '----------------'

So we can say:
	If both  (A  OR  B) {   1, 2, 3}  is True
				AND
	         (A NAND B) {0, 1, 2   }  is also True

	then we must have   {   1, 2   }  ... ie. an XOR

(o) One of the ways to make XOR using (N)AND/(N)OR Logic                        .
!  ..........  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    .
!  .  XOR  .                                                                    .
!  .........               +--._                                           .    .
!              .-------A----\   `-.        (AB) is {1,2,3}                      .
!  .           |             } OR ,'------.                                .    .
!              |   .---B----/  _,'        |                                     .
!  .           |   |       +--'           |                                .    .
!       (A)----+   |                      |     +-----.                         .
!  .           |   |                      `-----|      \    (AB) is {1,2}  .    .
!       (B)----}---+                            |  AND  }---(Y)                 .
!  .           |   |                      ,-----|      /                   .    .
!              |   |                      |     +-----'                         .
!  .           |   |       +-----.        |                                .    .
!              `---}---A---|      \  _    |                                     .
!  .               |       | NAND  }(_)---'                                .    .
!                  `---B---|      /        (AB) is {0,1,2}                      .
!  .                       +-----'                                         .    .
!                                                                               .
!  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    .

We've already made all these gates.

(o) OR                                                                          .
!                                                                               .
!                    (B)                                                        .
!                     |                                                         .
!                   __v__                                                       .
!             ,------o o------.                                                 .
!             |               |                                                 .
!             |      (A)      |                _                                .
!             |       |       |               (~)                               .
!             |     __V__     |                #                                .
!     [+V]----+------o o------+--------------[###]----------[Gnd]               .
!                                             (Y)                               .
!                                                                               .

(o) NAND                                                                        .
!                                                                               .
!                     (A)       (A)                                             .
!                      |         |                                              .
!                    __V__     __V__                                            .
!              ,------o o-------o o------.                                      .
!              |                         |                                      .
!              |            _            |                                      .
!              |           (~)           |                                      .
!              |            #            |                                      .
!     [+V]--*--+----------[###]----------+----[Gnd]                             .
!                          (Y)                                                  .
!                                                                               .

(o) AND                                                                         .
!                                                                               .
!                    (A)       (B)             _                                .
!                     |         |             (~)                               .
!                   __V__     __v__            #                                .
!     [+V]-----------o o-------o o-----------[###]----------[Gnd]               .
!                                             (Y)                               .
!                                                                               .

We need to do 3 things:
	1. Swap all the mechanical switches for electronic ones
	2. Link the gates up in the right order
	3. Create Input Busses for {A} and {B} ((2) Signal Distribution wires)

(o) XOR circuit (explanatory)                                                   .
!                                                                               .
!.............................................................................. .
!: ,--------------.                                                           : .
!: | Input Signal |              (A)     (B)                                  : .
!: | distribution |               |       |        ,--- More Current Limiting : .
!: `--------------'               *       *   <----'         Resistors here   : .
!:                                |       |                                   : .
!:                .---------------+-------+-------------.                     : .
!:                |                                     |                     : .
!:                |     ,-------------------------------}-------.             : .
!:                |     |                               |       |             : .
!:................|.....|............  .................|.......|.............: .
|                 |     |                               |       |               .
!.................|.....|............  .................|.......|.............. .
!:  .----.     (a)|     |(b)        :  : .------.    (a)|    (b)|             : .
!:  | OR |        |     |           :  : | NAND |       |       |             : .
!:  '----'      __V__   |           :  : '------'     __V__   __V__           : .
!:              |   |   |           :  :              |   |   |   |           : .
!:          ,---'   '---}-----.     :  :          ,---'   '---'   '--+--[Gnd] : .
!:          |           |     |     :  :          |                  |        : .
!:          |           |     | (y) :  :          |        (y)       |        : .
!: [+V]--*--+         __V__   +---. :  : [+V]--*--+--------.   ------'        : .
!:          |         |   |   |   | :  :                   |                  : .
!:          `---------'   '---'   | :  :      ,------------'                  : .
!:                                | :  :      |                               : .
!:................................|.:  :......|...............................: .
|                                 |           |                                 .
!.................................|...........|................................ .
!:  ,-----.                (a | b)|           |(a !& b)                       : .
!:  | AND |                       |           |                               : .
!:  `-----'                       |           |                    _          : .
!:                              __V__       __V__                 (~)         : .
!:                              |   |       |   |                  #          : .
!:   [+V]--*--------------------'   '--  ---'   '----------------[###]--[Gnd] : .
!:                                                                (Y)         : .
!:............................................................................: .
!                                                          (a | b) & (a !& b)   .
!                                                                               .

There is an (hopefully) obvious way to reduce the switch-count here...

(o) XOR circuit (reduced switch count)                                          .
! ...............................................................................
! :                                                                            :.
! :                               (A)     (B)                                  :.
! :                                |       |                                   :.
! :                                *       *                                   :.
! :                                |       |                                   :.
! :                .---------------+-------+-------------.                     :.
! :                |                                     |                     :.
! :                |     ,-------------------------------}-------.             :.
! :                |     |                               |       |             :.
! :................|.....|............  .................|.......|.............:.
|                  |     |                               |       |              .
! .................|.....|............  .................|.......|...............
! :  .----.     (a)|     |(b)        :  : .------.    (a)|    (b)|             :.
! :  | OR |        |     |           :  : | NAND |       |       |             :.
! :  '----'      __V__   |           :  : '------'     __V__   __V__           :.
! :              |   |   |           :  :              |   |   |   |           :.
! :          ,---'   '---}-----.     :  :          ,---'   '---'   '--+--[Gnd] :.
! :          |           |     |     :  :          |                  |        :.
! :          |           |     | (y) :  :          |        (Y)       |        :.
! : [+V]--*--+         __V__   +-------------------+-------[###]------'        :.
! :          |         |   |   |     :  :                    #                 :.
! :          `---------'   '---'     :  :                   (~)  (A ^ B)       :.
! :                                  :  :                    "                 :.
! :..................................:  :......................................:.
!                                                                               .

I encourage you to pause here, and take a minute to think about what happens
for each of the 4 input combinations: ie. {AB} = {00, 01, 10, 11}

Start at {+V}, and follow the path of least resistance to {Gnd}

Prove to yourself that you could explain to someone else why
the light only comes on if the two inputs are DIFFERENT

.
.
.

Let's pick a symbol which means:
	"Some switches organised in such a way that
	 The Output state is the Logical XOR of the (2) Input States"

The symbol for XOR, is the OR symbol with an extra line behind it:

(o) XOR pocket reference                                                        .
!                                                                               .
!                       +--{A}--+   +--{A}---{B}--+                             .
!                 (+)---+--{B}--+---+---- {Y}-----+---(-)                       .
!                                                                               .
!	    . +--._                                             | A | B |   Y   |   .
!	A----\ \   `-.                               _          +----+--+-------+   .
!	      ) }    ,'---Y       XOR/EOR       ---\\ `.___     | 0 | 0 |   0   |   .
!	B----/ /  _,'                           ---//_,'        | 0 | 1 |  =1=  |   .
!	    ' +--'                                              | 1 | 0 |  =1=  |   .
!                                                           | 1 | 1 |   0   |   .
!                                                                               .
!   if  ((A == 1) ^ (B == 1))  then  {Y=1}  else  {Y=0}                         .
!   if  (      (A != B)     )  then  {Y=1}  else  {Y=0}                         .
!                                                                               .


~~~~ ,-----------------------.                                                  .
~~~ (  Just for completeness  ) ================================================.
~~~~ `-----------------------'                                                  .

The output of an {XNOR} is
	FALSE if (EXclusively) *either* {A} *OR* {B} is True, but *NOT BOTH*
	Ie. FALSE if {A} and {B} are NOT-different
	Ie. TRUE  if {A} and {B} are the same

This logic is called a "XNOR" Gate
...It has a "Logic/Truth Table" that looks like this:

        .----------------.
        | INPUT | OUTPUT |
        | A | B |   Y    |
        +----+--+--------+
        | 0 | 0 |  =1=   |
	    | 0 | 1 |   0    |     XNOR : A == B
        | 1 | 0 |   0    |
        | 1 | 1 |  =1=   |
        '----------------'

Let's pick a symbol which means:
	"Two switches organised in such a way that
	 The Output state is the inverted logical XOR
	                         \_______(XNOR)_____/  of the (2) Input States"

The symbol for "XNOR" is an XOR with a NOT (tiny circle) after it

(o) XNOR pocket reference                                                       .
!                                                                               .
!                   (+)---Your Switch Diagram Here--(-)                         .
!	    . +--._                                             | A | B |   Y   |   .
!	A----\ \   `-.  _                            _          +----+--+-------+   .
!	      ) }    ,'(_)---Y    XNOR/ENOR     ---\\ `.o___    | 0 | 0 |  =1=  |   .
!	B----/ /  _,'                           ---//_,'        | 0 | 1 |   0   |   .
!	    ' +--'                                              | 1 | 0 |   0   |   .
!                                                           | 1 | 1 |  =1=  |   .
!                                                                               .
!   if  ((A == 1) ^ (B == 1))  then  {Y=0}  else  {Y=1}                         .
!   if  (      (A != B)     )  then  {Y=0}  else  {Y=1}                         .
!   if  (      (A == B)     )  then  {Y=1}  else  {Y=0}                         .
!                                                                               .

The switch circuit is ... Left as an exercise for the reader...

There is no "one correct answer"
When you come up with an arrangement of switches that makes the light come
on when both switches are in the same state {0,0} or {1,1} ... You win!


~~~~ ,-----------------------------.                                            .
~~~ (  NAND gates all the way down  ) ==========================================.
~~~~ `-----------------------------'                                            .

If you are sharp, you may have realised we can actually make ALL gates with
various combination of NAND gates...

(o) NAND pocket reference (using NAND gates)                                    .
!                                                                               .
!                                      ___                                      .
!                                A ---|   \                                     .
! NAND:    (A NAND B)                 |    )O--- Y                              .
!                                B ---|___/                                     .
!                                                                               .

(o) NOT pocket reference (using NAND gates)                                     .
!                                          ___                                  .
!                                     .---|   \                                 .
! NOT:     (A NAND A)            A ---+   |    )O--- Y                          .
!                                     `---|___/                                 .
!                                                                               .

(o) BUFFER pocket reference (using NAND gates)                                  .
!                                          ___           ___                    .
!                                     .---|   \     .---|   \                   .
! Buffer:  (NOT (A NAND A))      A ---+   |    )O---+   |    )O--- Y            .
!                                     `---|___/     `---|___/                   .
!                                                                               .

(o) AND pocket reference (using NAND gates)                                     .
!                                      ___          ___                         .
!                                A ---|   \     .--|   \                        .
! AND:     (NOT (A NAND B))           |    )O---+  |    )O--- Y                 .
!                                B ---|___/     `--|___/                        .
!                                                                               .

(o) OR pocket reference (using NAND gates)                                      .
!                                          ___                                  .
!                                     .---|   \                                 .
!          (A NAND A)            A ---+   |    )O--.    ___                     .
!              ||                     `---|___/     `--|   \                    .
! OR:         NAND                         ___         |    )O--- Y             .
!              ||                     .---|   \     ,--|___/                    .
!          (B NAND B)            B ---+   |    )O--'                            .
!                                     `---|___/                                 .
!                                                                               .

(o) XOR pocket reference (using NAND gates)                                     .
!                                                    ___                        .
!                                    ,--------------|   \                       .
!          (A NAND (A NAND B))       |   ___        | a' )O--.    ___           .
!                 ||             A --+--|   \    ,--|___/     `--|   \          .
! XOR/EOR:       NAND                   |    )O--+   ___         |    )O--- Y   .
!                 ||             B --+--|___/    `--|   \     ,--|___/          .
!          (B NAND (A NAND B))       |              | b' )O--'                  .
!                                    `--------------|___/                       .
!                                                                               .

!                                                                               .
!  ...ETC...                                                                    .
!                                                                               .

Exercise:
	Satisfy yourself that all the above Logic Diagrams work as expected.


~~~~ ,----------------------------.                                             .
~~~ (  NOR gates all the way down  ) ===========================================.
~~~~ `----------------------------'                                             .

You can do the same thing with NOR gates...

Left as an excercise for the reader.

People reading just for the "feel-good factor" can simply click this link:
	https://www.google.com/search?udm=2&q=logic+gates+using+nor
...and say "oh yeah, I could've worked that out".
	...Yes. EVERYONE can 'work it out' AFTER they've seen the answers ;)


~~~~ ,-----------------.                                                        .
~~~ (  Multiple Inputs  ) ======================================================.
~~~~ `-----------------'                                                        .

The 1-Input:1-Output Gates are (by their nature always 1-Input.

[*] Unless you're programming a quantum computer, then you have the
    2-Input:2-Output C-NOT Gate :-) ...Ignore that comment - lol.

But with the 2-Input Gates, it is well within reason that at some point in time
we may wish to have 3 or more Inputs.

~-~ Mutli-Input (N)AND Gates ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

If we want 3 or more inputs to {AND} or {NAND}...

I hope (if I have done my job well) it is obvious how we do that...

If you have {A} Tea AND {B} Milk AND {C} Water AND {D} Kettle
       then {Y} Cuppa = 1 ...else {Y} Cuppa = 0

["cuppa" is UK slang for "cup of tea"]

(o) Multiple Switches in series                                                 .
!                                                                               .
!                Tea       Milk     Water     Kettle                            .
!                (A)       (B)       (C)       (D)             _                .
!                 |         |         |         |             (~)               .
!               __V__     __V__     __V__     __v__            #                .
!   [+V]---------o o-------o o-------o o-------o o-----------[###]----[Gnd]     .
!                                                             (Y)               .
!                                                       "fresh cup of           .
!                                                        really hot tea"        .
!                                                                               .

I will let you work out Multi-Input {NAND}

~-~ Mutli-Input (N)OR Gates  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

If we want 3 or more inputs to {OR} or {NOR}...

Again, I hope (if I have done my job well) it is obvious how we do that too

If tea has {A} Sugar OR {B} Soy Milk OR {C} Scum OR {D} Bergamot
      then {Y} Poison = 1 ...else {Y} Poison = 0

(o) Multiple Switches in parallel                                               .
!                                                                               .
!                    (D)                                                        .
!                     |                                                         .
!                   __v__                                                       .
!             ,------o o------.                                                 .
!             |               |                                                 .
!             |      (C)      |                                                 .
!             |       |       |                                                 .
!             |     __v__     |                                                 .
!             +------o o------+                                                 .
!             |               |                                                 .
!             |      (B)      |                                                 .
!             |       |       |                                                 .
!             |     __v__     |                                                 .
!             +------o o------+                                                 .
!             |               |                                                 .
!             |      (A)      |                _                                .
!             |       |       |               (~)                               .
!             |     __V__     |                #                                .
!     [+V]----+------o o------+--------------[###]----------[Gnd]               .
!                                             (Y)                               .
!                                                                               .

I will let you work out Multi-Input {NOR}

~-~ Mutli-Input X(N)OR Gates ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

The {XOR, XNOR} gates are "complex"/"compound" Gates,
so we cannot apply the same "well that's obvious" thinking.

The way to do
	{A} XOR {B} XOR {C} XOR {D}
is to perform
	( ( {A} XOR {B} ) XOR {C} ) XOR {D}

So quite literally a chain of XOR Gates:

(o) A XOR B XOR C XOR D : Symbolic Diagram                                      .
!	     . +--._                                                                .
!	 A----\ \   `-.    p                                                        .
!	       ) }    ,'---.                                                        .
!	 B----/ /  _,'     |    . +--._                                             .
!	     ' +--'        `-----\ \   `-.    q                                     .
!                             ) }    ,'---.                                     .
!    C-----------------------/ /  _,'     |   . +--._                           .
!                           ' +--'        `----\ \   `-.                        .
!                                               ) }    ,'---Y                   .
!    D-----------------------------------------/ /  _,'                         .
!                                             ' +--'                            .
!                                                                               .

There are (2^4 = 16) possible input cominations...

(o) A XOR B XOR C XOR D : TL;DR                                                 .
!                                                                               .
!  |    |  A  B  C  D  |  | A ^ B |  p  |---| p ^ C |  q  |---| q ^ D |  Y  |   .
!  |----|--------------|  |-------|-----|   |-------|-----|   |-------|-----|   .
!  |    |              |  |       |     |   |       |     |   |       |     |   .
!  |  0 |  0  0  0  0  |  | 0 ^ 0 |  0  |---| 0 ^ 0 |  0  |---| 0 ^ 0 |  0  |   .
!  |  1 |  0  0  0  1  |  | 0 ^ 0 |  0  |---| 0 ^ 0 |  0  |---| 0 ^ 1 |  1  |   .
!  |  2 |  0  0  1  0  |  | 0 ^ 0 |  0  |---| 0 ^ 1 |  1  |---| 1 ^ 0 |  1  |   .
!  |  3 |  0  0  1  1  |  | 0 ^ 0 |  0  |---| 0 ^ 1 |  1  |---| 1 ^ 1 |  0  |   .
|  |    |              |  |       |     |   |       |     |   |       |     |   .
!  |  4 |  0  1  0  0  |  | 0 ^ 1 |  1  |---| 1 ^ 0 |  1  |---| 1 ^ 0 |  1  |   .
!  |  5 |  0  1  0  1  |  | 0 ^ 1 |  1  |---| 1 ^ 0 |  1  |---| 1 ^ 1 |  0  |   .
!  |  6 |  0  1  1  0  |  | 0 ^ 1 |  1  |---| 1 ^ 1 |  0  |---| 0 ^ 0 |  0  |   .
!  |  7 |  0  1  1  1  |  | 0 ^ 1 |  1  |---| 1 ^ 1 |  0  |---| 0 ^ 1 |  1  |   .
|  |    |              |  |       |     |   |       |     |   |       |     |   .
!  |  8 |  1  0  0  0  |  | 1 ^ 0 |  1  |---| 1 ^ 0 |  1  |---| 1 ^ 0 |  1  |   .
!  |  9 |  1  0  0  1  |  | 1 ^ 0 |  1  |---| 1 ^ 0 |  1  |---| 1 ^ 1 |  0  |   .
!  | 10 |  1  0  1  0  |  | 1 ^ 0 |  1  |---| 1 ^ 1 |  0  |---| 0 ^ 0 |  0  |   .
!  | 11 |  1  0  1  1  |  | 1 ^ 0 |  1  |---| 1 ^ 1 |  0  |---| 0 ^ 1 |  1  |   .
|  |    |              |  |       |     |   |       |     |   |       |     |   .
!  | 12 |  1  1  0  0  |  | 1 ^ 1 |  0  |---| 0 ^ 0 |  0  |---| 0 ^ 0 |  0  |   .
!  | 13 |  1  1  0  1  |  | 1 ^ 1 |  0  |---| 0 ^ 0 |  0  |---| 0 ^ 1 |  1  |   .
!  | 14 |  1  1  1  0  |  | 1 ^ 1 |  0  |---| 0 ^ 1 |  1  |---| 1 ^ 0 |  1  |   .
!  | 15 |  1  1  1  1  |  | 1 ^ 1 |  0  |---| 0 ^ 1 |  1  |---| 1 ^ 1 |  0  |   .
!  |    |              |  |       |     |   |       |     |   |       |     |   .
!                                                                               .

If you've spotted the pattern, colour me impressed.

If not, Don't worry - it's really NOT obvious!

For each line {0 .. 15},
    Count how many Inputs {A, B, C, D} are "1"
        If the count is ODD      the final Output {Y} will be 1
        If the count is EVEN [*] the final Output {Y} will be 0

[*] "Even" is given to mean "divisble by 2", so 0 is Even

A very famous use for this is a form of error checking known as "Parity"

{XOR} calculates "Even Parity"
	If the count is ODD, we set {Y} to 1,
	so the final total count, INCLUDING the Output. {A, B, C, D, Y} is Even

{XNOR} calculates "Odd Parity"
	If the count is EVEN, we set {Y} to 1,
	so the final total count, INCLUDING the Output. {A, B, C, D, Y} is Odd

I will let you work out Multi-Input {XNOR}
...Remember: {XNOR} ALWAYS gives the opposite result to {XOR}


~~~~ ,----------------------.                                                   .
~~~ (  WTF is a Transistor?  ) =================================================.
~~~~ `----------------------'                                                   .

Before we start building a computer from nothing but transistors [*],
we should probably learn exactly what a transistor is!

Actually. Scrub that.
We should probably learn JUST ENOUGH about transistors to "build Logic Gates".

[*] and "current limiting resistors"

We all know you can use transistors to build amplifiers.
...There will be NOTHING (more) about this feature in this document.

You may even know there are lots of different types of transistor:
	{BJT, NPN, PNP, MOSFET, JFET, HBT, MET, Avalanche, Diffusion,
	 N Channel, P Channel, Depletion, Enhancement, etc., etc.}

We only care about the "N-Channel Enhancement-Mode MOSFET" variety, because
	# MOSFETs : are good (not great) at being simple switches!
	# Enhancement-Mode : is the 'intuitive' Push-To-Make type of switch
	# N-Channel : are literally 1/10th the price of P-Channel MOSFETs!
	              ...I'll take the "buy 1, get 9 free" deal please [qv. Farnell]

The metaphor for MOSFETs is that they act like a (garden) gate.
    When the gate is  OPEN , electricity can flow
	                                      from one side of the gate to the other
	When the gate is CLOSED, electricity flow is BLOCKED

The MOSFETs we will consider have 3 (not 4) legs, {Gate, Source, Drain} -{Body}-

(o) The "N-Channel Enhancement-Mode MOSFET"                                     .
!                                                                               .
!	Gate   : [+V] GATE is open ... [Gnd] GATE is closed               [*1]      .
!	Drain  : DRAINS power from the 'battery' ("[+V]")                           .
!	Source : Provides a SOURCE of power for the rest of the circuit   [*2]      .
!                                                                               .
!	$Cost  : Cheap                                                              .
!                                                                               .

[*1] It is physically possible to not-connect the Gate to anything,
     aka. a "floating Gate" or, more generally, a "floating pin".
	 I've addedd a short footnote about this [below]
                                      <~ Spoiler : We will simply Never do it ~>

[*2] "the rest of the circuit" may be anything
     as much as some industrial machinery,
	 or as little a piece of wire
     ...and anything in between.
	 BUT: Remember: Electricity flows from {+V} to {Gnd}
	 SO:  Whatever it is - it MUST always, ultimately, provide a path to {Gnd}


Just to add to the confusion, N-Channel Enhancement-Mode MOSFETs
have MANY (more than 4) equally valid circuit symbols! "\_o_/"

(o) FOUR equally valid Circuit Symbols for "N-Channel Enhancement-Mode MOSFET"  .
!                                                                               .
!              Gate                                       Gate                  .
!              |                                          |                     .
!              |  _____                                 __|__                   .
!              |-'     `-.                           .-'  |  `-.                .
!            ,'|          `.                       ,'     |     `.              .
!           ;  |_________   :                     ;   ____|____   :             .
!          :   ___ ___ ___   :                   :   ___________   :            .
!          |    |   |   |    |                   |    |       |    |            .
!          :    |  /|\  |    :                   :    |       |    :            .
!           :   |   |   |   ;                     :   |      \|/  ;             .
!   Drain ------'   '---------- Source    Drain ------'       `------ Source    .
!              `-._____,-'                           `-._____,-'                .
!                                                                               .
!                                                                               .
!              Gate                                       Gate                  .
!              |                                          |                     .
!              |  _____                                   |                     .
!              |-'     `-.                                |                     .
!            ,'|          `.                              |                     .
!           ;  |_________   :                         ____|____                 .
!          :   ___ ___ ___   :                       ___________                .
!          |    |   |   |    |                        |       |                 .
!          :    |  /|\  |    :                        |       |                 .
!           :   |   |   |   ;                         |      \|/                .
!   Drain ------'   |   '------ Source    Drain ---+--'       `--+--- Source    .
!              `-.__|__,-'                         |             |              .
!                   |                              `------<|-----'              .
!                   Body                                                        .
!                                                                               .

~-~ Nomenclature ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

A choice needs to be made ...We will, for ease of ASCII art, use these symbols:

(o) N-Channel Enhancement-Mode MOSFET .. Our Symbol                             .
!                                                                               .
!               G                                                               .
!               |                                      G                        .
!            ___|___                                   |                        .
!          ___________                               _---_                      .
!           |       |                                |   v                      .
!           |       |                  [+V]--->  D---'   '---S  --->[Gnd]       .
!           |      \|/                                                          .
!   D ------'       `------ S                                                   .
!                                                                               .
!                     N-Channel Enhancement-Mode MOSFET                         .
!                                                                               .
!    G = [+V]  : Electricity may     flow from [+V] Drain -to- Source [Gnd]     .
!    G = [Gnd] : Electricity may NOT flow                                       .
!                                                                               .

Also:
I am not going to keep typing "N-Channel Enhancement-Mode MOSFET".
So, henceforth, in this document, unless otherwise stated, when I refer to
"a transistor" or "a MOSFET", I am referring specifically to an
"N-Channel Enhancement-Mode MOSFET" (eg. 2N7000).

~-~ Floating Values ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .

If you do not connect an {Input} to either {+V} or {Gnd},
...this is known as a "Floating" Input
...and it's State {1, 0} is "Undefined"

NB. In Real Life, when an Input is "Floating", its state will depend on
    (generally uncontrollable) physical & environmental factors.

As a programmer, you could aliken it to an "Unintialised Variable".
...They are (almost) always bad:

	https://www.schneier.com/blog/archives/2008/05/random_number_b.html

    !!! In this guide, we will simply NEVER leave an INPUT Floating !!!

~-~ Voltage or Current?  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

There is MUCH debate as to whether we should explain any transistor in terms of:
	# Current .. popular with Electronics Engineers
	# Voltage .. popular with Physicists

The two are very closely related, and if you ever want "the other one",
there are some simple equations that let you move from one to the other
(aka. "Ohms Law")                         <~ Spoiler : We will Never need it ~>

If/when we need a metaphor, we will pick whichever one makes things easiest!
...We will leave the sub-atomic physics to the people who design them ;)

https://electronics.stackexchange.com/questions/71144/is-bjt-a-voltage-controlled-device-or-current-controlled-device


~~~~ ,---------------.                                                          .
~~~ (  THE DICHOTOMY  ) ========================================================.
~~~~ `---------------'                                                          .

We have a dilemma!

For reasons that I'm simply NOT going to explain...
If we only use ONE type of transistor, we can make:
	EITHER
		{AND, OR, BUFFER} gates (Positive logic)
		...which requires P-Channel (expensive) MOSFETs
		easy to "read" : If Tea=1 AND Milk=1 then MakeTea(1)
	OR (XOR)
		{NAND, NOR, NOT}  gates (Negative logic)
		...which requires N-Channel (cheap) MOSFETs
		tricky to "read" : If Tea=1 NAND Milk=1 then MakeTea(0)

Despite the fact that P-Channel MOSFETs are *literally* 10x the price,
we COULD buy BOTH types of transistor and use ALL the gates.

Let's Stop and consider the goal here:
	We want to undestand how these "switch groupings" (aka "gates")
	can be used as a computer
...So let's keep our options in scope
   of the problem we are actually trying to solve...

When you are making billions of these tiny (>=2nM) switches, on a piece of
silicon smaller than your thumbnail, you keep the process SIMPLE.
So we will pick ONE of the options.

# If we pick the "easy to read"(/expensive) MOSFETs
  it will be impossible to turn a 1 in to a 0 (or vice versa)
# If you cannot count from 0 to 1 (nor from 1 to 0)
  adding up is going to be impossible!

# If we pick the "tricky to read"(/cheap) MOSFETs
  We CAN turn a 1 in to a 0 (and a 0 to a 1)
# And already we have a computer that can
    count forwards from 0 to 1
    and backwards  from 1 to 0

In the previous section I make a big point about repeating:
	"N-Channel Enhancement-Mode MOSFET"
So you're not going to be surprised where this is heading...

We are, pretty much, like those before us, forced to use:
	"N-Channel Enhancement-Mode MOSFET"s
And therefore, we have to do everything with {NAND, NOR, NOT} gates!

So the question becomes this:
	Can you make the {BUFFER, AND, OR} gates using only {NAND, NOR, NOT} gates!

~~~~ ,----------------------------.                                             .
~~~ (  De-confusing Inverse Logic  ) ===========================================.
~~~~ `----------------------------'                                             .

Very little human lanugage (certainly English) is built around Inverse Logic.

Sentences like "If Tea=1 NAND Milk=1 then MakeTea(0)" are difficult to read
and we'd really like to avoid it as much as possible...

Luckily it is a problem we only ever need to solve ONCE :-)

When we design the logic for a computer,
we NEVER actually draw out all of the individual switches
we use the Gate Symbols
  ...they are "black boxes"
  ...we DON'T CARE about their internal anatomy
  ...we just need them to do the thing they claim to do!

So if we can find ONE way to make a {BUFFER} out of {NOT, NAND, NOR} gates
we will be allowed to draw/use the {BUFFER} symbol.

The {BUFFER} is (hopefully, by now) pretty obvious:

(o) A "BUFFER" using "NOT" Gates                                                .
!                               :                              :                .
|	1 ->    {BUFFER}    -> 1    :   0 ->    {BUFFER}    -> 0   :  <--.          .
!                               :                              :     |   The    .
!	1 ->      {NOT}     -> 0    :   0 ->      {NOT}     -> 1   :     |-- Same   .
!                               :                              :     |   Result .
|	1 -> {NOT} -> {NOT} -> 1    :   0 -> {NOT} -> {NOT} -> 0   :  <--'          .
!                               :                              :                .

How about "AND" and "OR"

~-~ Three Negatives make a Positive  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

You may remember the "Top Secret Spoiler Alert" from earlier.
I said I would revist two of the equivalence formulae:
...This is that moment!

(o) Logical Equivalents                                                         .
!                                                                               .
!	( A  OR  B )  ===  ( !A NAND !B )                                           .
!	( A  AND B )  ===  ( !A NOR  !B )                                           .
!                                                                               .

I'll walk you through one of them, and leave you to do the other one yourself.

(o) Proof: ( A  OR  B ) === ( !A  NAND  !B )  ... In English                    .
!                                                                               .
!     :              :          :                :        :                     .
! If  :   HAVE Tea   :     OR   :   HAVE Coffee  :  then  :   HAVE HotDrink     .
!     :   |          :     |    :   |            :        :   |                 .
!     :   |          :     |    :   |            :        :   |                 .
!     :  (invert)    :  (swap)  :  (invert)      :        :  (invert)           .
!     :    |         :     |    :   |            :        :    |                .
!     :    |         :     |    :   |            :        :    |                .
! If  :    NO  Tea   :  [N]AND  :   NO  Coffee   :  then  :    NO  HotDrink     .
!     :              :   |      :                :        :    ^^               .
|                        :                                     ::               .
|                        '-->------------------------------->--''               .
!              Remember: The "N" prefix on "NAND" or "NOR" inverts the OUTPUT!  .
!                                                                               .
!                         +-----.                    +--._                      .
!                     A---|      \  _            A----\   `-.  _                .
!                         | NAND  }(_)---Y             }NOR ,'(_)---Y           .
!                     B---|      /               B----/  _,'                    .
!                         +-----'                    +--'                       .
!                                                                               .


(o) Proof: ( A  OR  B ) === ( !A  NAND  !B )                                    .
!                                                                               .
!    | A | B |  OR   |    | A |  NOT  |    | A | B | NAND  |    | B |  NOT  |   .
!    |-------|-------|    |---|-------|    |-------|-------|    |---|-------|   .
!    | 0 | 0 |   0   |    | 0 |  =1=  |    | 0 | 0 |  =1=  |    | 0 |  =1=  |   .
!    | 0 | 1 |  =1=  |    | 1 |   0   |    | 0 | 1 |   0   |    | 1 |   0   |   .
!    | 1 | 0 |  =1=  |                     | 1 | 0 |   0   |                    .
!    | 1 | 1 |  =1=  |                     | 1 | 1 |   0   |                    .
!                                                                               .
|														                        .
!                                                                               .
!	( A  OR  B )        ===   ( !A  NAND  !B )                                  .
!................................................................................
!                                                                               .
!	( 0  OR  0  ==0 )   -->   ( !0  NAND  !0 )                                  .
!	                          (  1  NAND   1 )  ==0                             .
!................................................................................
!                                                                               .
!	( 0  OR  1  ==1 )   -->   ( !0  NAND  !1 )                                  .
!	                          (  1  NAND   0 )  ==1                             .
!................................................................................
!                                                                               .
!	( 1  OR  0  ==1 )   -->   ( !1  NAND  !0 )                                  .
!	                          (  0  NAND   1 )  ==1                             .
!................................................................................
!                                                                               .
!	( 1  OR  1  ==1 )   -->   ( !1  NAND  !1 )                                  .
!	                          (  0  NAND   0 )  ==1                             .
!................................................................................
!                                                                               .

Finally, the circuit:

We are now in the world of transistors, so let's swap the lightbulb for an LED.

LEDs are NOT "resistive loads" so if you build this with actual components,
you will need another one of those damn "current limiting resistors"

(o) LED Symbol                                                                  .
!                                                                               .
!           ,,                                                                  .
!    ------|>|---     LED                                                       .
!                                                                               .
!           ,,                                                                  .
!    ----*-|>|---     LED with Current Limiting Ressitor                        .
!                                                                               .


(o) Circuit : ( !A NAND !B ) == ( A OR B )                                      .
!                                                                               .
!    .................|...............     .................|...............    .
!    : .-----.     (A)|              :     : .-----.     (B)|              :    .
!    : | NOT |        |              :     : | NOT |        |              :    .
!    : '-----'      _---_            :     : '-----'      _---_            :    .
!    :              |   v            :     :              |   v            :    .
!    :          ,---'   '---.        :     :          ,---'   '---.        :    .
!    :          |           |        :     :          |           |        :    .
!    :          |           |        :     :          |           |        :    .
!    : [+V]--*--+---.  .----+--[Gnd] :     : [+V]--*--+---.  .----+--[Gnd] :    .
!    :              |                :     :              |                :    .
!    :              |                :     :              |                :    .
!    :              | !A             :     :           !B |                :    .
!    :..............|................:     :..............|................:    .
|                   |                                     |                     .
|                   '---------------.       .-------------'                     .
|                                   |       |                                   .
!                  .................|.......|..............                     .
!                  : .------        |       |             :                     .
!                  : | NAND |       |       |             :                     .
!                  : '------'     _---_   _---_           :                     .
!                  :              |   v   |   v           :                     .
!                  :          ,---'   '---'   '--.        :                     .
!                  :          |                  |        :                     .
!                  :          |          ,,      |        :                     .
!                  : [+V]--*--+-------*-|>|------+--[Gnd] :                     .
!                  :                    (Y)               :                     .
!                  :......................................:                     .
!                                                                               .

~-~ Your Turn -~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

Again, if you want to rememeber this, the only way is to play with it.
There is nothing to gain from me repeating this exercise at you for {AND/NOR}

Come up with two English sentences (or for that matter, any language)
which make the equality clear, eg.:
	# If you       have stuff, you can   do a thing
	# If you don't have stuff, you can't do a thing

Then grab the truth tables you need ...and run the four possible examples.

Then draw it as a circuit diagram.
...You may prefer a pencil & paper, but cut'n'paste ASCII art is acceptble ;)

Ie. Prove that you could explain it (simply and clearly) to someone else:
	( A AND B ) === ( !A NOR !B )


~~~~ ,-------------------------------.                                          .
~~~ (  The Summary before the Finale  ) ========================================.
~~~~ `-------------------------------'                                          .

Let's review everything we have done.

Using 1 physical switch, we have made:
	BUFFER      NOT

Using 2 physical switches, we have made:
	AND         NAND
	OR          NOR

!                                                                               .
!  ,--------------------------------------.                                     .
!  |     Switches     |      Output       |                                     .
!  | count |  Layout  | Position | Value  |                                     .
!  |-------|----------|----------|--------|                                     .
!  |   1   |   n/a    |  series  | BUFFER | (we wil almost never use this one)  .
!  |       |          | parallel | NOT    | aka. INVERTER                       .
!  |-------|----------|-------------------|                                     .
!  |       |  series  |  series  |  AND   |                                     .
!  |       |          | parallel | NAND   |  ie. AND with a NOT on the output   .
!  |   2   |----------|-------------------|                                     .
!  |       | parallel |  series  |  OR    |                                     .
!  |       |          | parallel | NOR    |  ie. OR with a NOT on the output    .
!  '--------------------------------------'                                     .
!                                                                               .

For each of these, we:
	# Drew out the Logic/Truth Table
	# Simulated it with a line of source code
	# Drew the switch circuit
	# Designed an ASCII art symbol [*]

[*] So, going forward, we can use the Symbol
    rather than have to draw all the individual switches every time

Then we swapped out the  physical switches  for  electronic switches
    and swapped out the     lightbulbs      for  LEDs

We learned that if the Output is in  Series,    we need  P-Channel  transistors
            and if the Output is in  Parallel,  we need  N-Channel  transistors

Ie. Positive-Channel MOSFETs, are used to make {  BUFFER,  AND,  OR}
    Negative-Channel MOSFETs, are used to make {INVERTER, NAND, NOR}

We chose to use (only) N-Channel MOSFETs : {NOT, NAND, NOR}
Then, using "equivalence logic", we worked out how to make
	{BUFFER, AND, OR} from {NOT, NAND, NOR}

!                                                                               .
!  BUFFER X  ==  NOT(X) then NOT(X)     ie. NOT( NOT(X) )                       .
!  A AND B   ==  NOT(A) NOR  NOT(B)                                             .
!  A OR  B   ==  NOT(A) NAND NOT(B)                                             .
!                                                                               .

We linked some Gates together to make    {XOR}    and    {XNOR}
so that we can see if two inputs are  "different" or   "the same"

We even side-tracked a few times, and discussed:

	# The Conventional Current metaphor, where electricity flows from (+) to (-)
	  ...and why physicists get upset by it

	# How electricity always travels via "the path of least resisitance"
      ...and how this is a massive over-simplification can be clarified by some
	     intense reading and analysis of Kirchhoff's Laws (along with Ohm's law)
	  ...and decided we really didn't care about the detail - and kept walking!

	# Current Limiting Resistors
	  ...and how they  DON'T  change any Logical function
		 so we can ignore them
	  ...but they  DO  stop real-life circuits from melting/exploding
	     so if we build something, we need to remember to add them

	# Floating Inputs
	  ...and why we will simply never have them

	# Implication gates
	  ...and where they are used ...ie. by genetic (not computer) program(mer)s

	# The transistor "Voltage" and "Current" metaphors
	  ...and how they don't matter to us


~~~~ ,-----------------.                                                        .
~~~ (  The Gate Finale  ) ======================================================.
~~~~ `-----------------'                                                        .

Let's tidy up these switch diagrams, and turn them in to useful "Schematics"...

The ones we have so far are perfectly valid,
but not very "Schematic-" or "PCB Layout-" friendly

~-~ Three Steps  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

== 1 ==

We chose to use N-Channel MOSFETs.
So we will draw Schematic Diagrams for {NOT, NAND, NOR}

== 2 ==

In the previous section, we created {AND, OR} from {NOT, NAND, NOR} Gates
(by using Equivalence Logic).

You will be invited to repeat that exercise using
the new Schematic-friendly diagrams from step 1.

== 3 ==

A while back, we designed the {XOR} gate using {NOT, OR, NAND},
We will redraw that using the Switch Schematics from steps 1 & 2

== 4 ==

Then we will, *AT LONG LAST*, move on to building a computer with them.

~-~ Step 1a - "NOT"  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.


(o) "NOT" Switch Circuit                                                        .
!                                                                               .
!     NOT             (A)                                                       .
!                      |                                                        .
!                    _---_                                                      .
!                    |   v                                                      .
!              ,-----'   '-----.                                                .
!              |               |                                                .
!              |        ,,     |                                                .
!     [+V]--*--+-----*-|>|-----+----[Gnd]                                       .
!                      (Y)                                                      .
!                                                                               .

In Schematics, we are allowed to put {+V} and {Gnd} as many times as we like.
{+V}  will ALWAYS mean: directly connected to {+V}  ...eg. Battery (+)
{Gnd} will ALWAYS mean: directly connected to {Gnd} ...    Battery (-)

So this is equally as valid:
(o) "NOT" Switch Schematic - Multiple Gnd's                                     .
!                                                                               .
!     NOT             (A)                                                       .
!                      |                                                        .
!                    _---_                                                      .
!                    |   v                                                      .
!              ,-----'   '----------[Gnd]                                       .
!              |                                                                .
!              |        ,,                                                      .
!     [+V]--*--+-----*-|>|----------[Gnd]                                       .
!                      (Y)                                                      .
!                                                                               .

We don' really need the LED.

The point in the circuit labelled as {Y} will (depending on the state of the
switch) either be {+V/High/True/1} or {Gnd/Low/False/0} ...because physics.
If we take away the LED, it will still happen,
...we just won't be able to SEE it any more.

Let's lose the LED
...If there's ever a place where SEEing the 1's and 0's would look "awesome",
   we can always add some back in later ;)

(o) "NOT" Switch Schematic - Remove LED                                         .
!                                                                               .
!     NOT             (A)                                                       .
!                      |                                                        .
!                    _---_                                                      .
!                    |   v                                                      .
!              ,-----'   '----------[Gnd]                                       .
!              |                                                                .
!              |                                                                .
!     [+V]--*--+------{Y}-----------[Gnd]                                       .
!                                                                               .
!                                                                               .

We 'prefer' that  Inputs   go in at the  Top    (or left)  of the Schematic
             and  Outputs  come out the  Bottom (or Right) of the Schematic

Let's spin that Output around 90 degrees

(o) "NOT" Switch Schematic - Move Output                                        .
!                                                                               .
!     NOT             (A)                                                       .
!                      |                                                        .
!                    _---_                                                      .
!                    |   v                                                      .
!              ,-----'   '----------[Gnd]                                       .
!              |                                                                .
!              |                                                                .
!     [+V]--*--+                                                                .
!              |                                                                .
!              |                                                                .
!             {Y}                                                               .
!              |                                                                .
!              |                                                                .
!            [Gnd]                                                              .
!                                                                               .

That diagram really doesn't need to be that tall...

(o) "NOT" Switch Schematic - Move Input                                         .
!                                                                               .
!     NOT            (A)                                                        .
!                     |                                                         .
!                   _---_                                                       .
!                   |   v                                                       .
!     [+V]--*--+----'   '----------[Gnd]                                        .
!              |                                                                .
!              |                                                                .
!             {Y}                                                               .
!              |                                                                .
!              |                                                                .
!            [Gnd]                                                              .
!                                                                               .

Earlier we said every Output {Y} will go to "the rest of the circuit"
We then defined "the rest of the circuit" as being:
     as much as some industrial machinery,
	 or as little a piece of wire
     ...and anything in between.
	 BUT: Remember: Electricity flows from {+V} to {Gnd}
	 SO:  Whatever it is - it MUST always, ultimately, provide a path to {Gnd}

Currently our output is being shown as "always goes straight to ground"
and this is obviously not true.
...Sometimes/Often we will want the Output to go to Input of another Gate.

The wire to Ground IS "the rest of the circuit"
It is NOT a part of the actual Gate itself

So. Let's remove the (useless) output device (a wire that goes straight to Gnd).
And leave: Just the (point where you can "see" the) Output

BUT REMEMBER:
  The very last gate in any chain, MUST go to
  <something> which provides a pathway to {Gnd}

(o) "NOT" Schematic - Just the gate                                             .
!                                                                               .
!     NOT            (A)                                                        .
!                     |                                                         .
!                   _---_                                                       .
!                   |   v                                                       .
!     [+V]--*--+----'   '----------[Gnd]                                        .
!              |                                                                .
!              |                                                                .
!             {Y}                                                               .
!                                                                               .

Much Better :)

~-~ Step 1b - "NAND" ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

(o) "NAND" Switch Diagram                                                       .
!                                                                               .
!                     (A)       (B)                                             .
!                      |         |                                              .
!                    __V__     __V__                                            .
!              ,------o o-------o o------.                                      .
!              |                         |                                      .
!              |            _            |                                      .
!              |           (~)           |                                      .
!              |            #            |                                      .
!     [+V]--*--+----------[###]----------+----[Gnd]                             .
!                                                                               .

I'll do this in one big step:

(o) "NAND" Schematic - Just the Gate                                            .
!                                                                               .
!                     (A)       (B)                                             .
!                      |         |                                              .
!                    _---_     _---_                                            .
!                    |   v     |   v                                            .
!     [+V]--*--+-----'   '-----'   '-----[Gnd]                                  .
!              |                                                                .
!              |                                                                .
!             {Y}                                                               .
!                                                                               .

~-~ Step 1c - "NOR"  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

(o) "NOR" Switch Diagram                                                        .
!                                                                               .
!                     (A)                                                       .
!                      |                                                        .
!                    __V__                                                      .
!              ,------o o------.                                                .
!              |               |                                                .
!              |      (B)      |                                                .
!              |       |       |                                                .
!              |     __V__     |                                                .
!              +------o o------+                                                .
!              |               |                                                .
!              |       _       |                                                .
!              |      (~)      |                                                .
!              |       #       |                                                .
!     [+V]--*--+-----[###]-----+----[Gnd]                                       .
!                     (Y)                                                       .
!                                                                               .

I'm going to make this one -wider-, so I can bring the {B} Input to the top.

(o) "NOR" Schematic - Just the Gate                                             .
!                                                                               .
!                   (A)     {B}                                                 .
!                    |       |                                                  .
!                  _---_     |                                                  .
!                  |   v     |                                                  .
!              ,---'   '-----}-----.                                            .
!              |             |     |                                            .
!              |             |     |                                            .
!              |           _---_   |                                            .
!              |           |   v   |                                            .
!     [+V]--*--+-----------'   '---+----[Gnd]                                   .
!              |                                                                .
!              |                                                                .
!             {Y}                                                               .
!                                                                               .

~-~ Step 2 - "AND" and "OR"  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

Using the diagrams from Step 1 : {NOT, NAND, NOR}

And some Equivalence Logic:

!                                                                               .
!  BUFFER X  ==  NOT(X) then NOT(X)     ie. NOT( NOT(X) )                       .
!  A AND B   ==  NOT(A) NOR  NOT(B)                                             .
!  A OR  B   ==  NOT(A) NAND NOT(B)                                             .
!                                                                               .

Draw the schematics for {AND} and {OR}.

As I said right at the start:
If you're "just curious", feel free to skip this challenge.
If you're serious about understading this, take this opportunity to play

~-~ Step 3 - "X(N)OR" -~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

Remember:
	{XOR}       Different
	{XNOR}  NOT Different    (ie. the same)

Using the diagrams from Step 1 : {NOT, NAND, NOR}
                    and Step 2 : {      AND,  OR}

Draw the schematics for {XOR} and {XNOR}.

(o) One of the ways to make XOR using (N)AND/(N)OR Logic                        .
!  ..........  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    .
!  .  XOR  .                                                                    .
!  .........               +--._                                           .    .
!              .-------A----\   `-.        (AB) is {1,2,3}                      .
!  .           |             } OR ,'------.                                .    .
!              |   .---B----/  _,'        |                                     .
!  .           |   |       +--'           |                                .    .
!       (A)----+   |                      |     +-----.                         .
!  .           |   |                      `-----|      \    (AB) is {1,2}  .    .
!       (B)----}---+                            |  AND  }---(Y)                 .
!  .           |   |                      ,-----|      /                   .    .
!              |   |                      |     +-----'                         .
!  .           |   |       +-----.        |                                .    .
!              `---}---A---|      \  _    |                                     .
!  .               |       | NAND  }(_)---'                                .    .
!                  `---B---|      /        (AB) is {0,1,2}                      .
!  .                       +-----'                                         .    .
!                                                                               .
!  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    .

!                                                                               .
!.............................................................................. .
!: ,--------------.                                                           : .
!: | Input Signal |              (A)     (B)                                  : .
!: | distribution |               |       |                                   : .
!: `--------------'               *       *                                   : .
!:                                |       |                                   : .
!: ,---------------------+--------'       `---------------+-----------------. : .
!: |                     |                                |                 | : .
!:.|.....................|................................|.................|.: .
|  |                     |                                |                 |   .
!  | ....................|................................|................ |   .
!  | : OR                |                                |               : |   .
!  | :  .................|.............  .................|.............  : |   .
!  | :  : .-----.     (A)|            :  : .-----.     (B)|            :  : |   .
!  | :  : | NOT |        |            :  : | NOT |        |            :  : |   .
!  | :  : '-----'      _---_          :  : '-----'      _---_          :  : |   .
!  | :  :              |   v          :  :              |   v          :  : |   .
!  | :  : [+V]--*--+---'   '----[Gnd] :  : [+V]--*--+---'   '----[Gnd} :  : |   .
!  | :  :          |                  :  :          |                  :  : |   .
!  | :  :..........|..................:  :..........|..................:  : |   .
!  | :          !A '________________         _______' !B                  : |   .
!  | :                              |       |                             : |   .
!  | :             .................|.......|.............                : |   .
!  | :             : .------.       |       |            :                : |   .
!  | :             : | NAND |       |       |            :                : |   .
!  | :             : '------'     _---_   _---_          :                : |   .
!  | :             :              |   v   |   v          :                : |   .
!  | :             : [+V]--*--+---'   '---'   '----[Gnd] :                : |   .
!  | :             :          |                          :                : |   .
!  | :             :..........|..........................:                : |   .
!  | :                        | !A NAND !B                                : |   .
!  | :........................|...........................................: |   .
!  |                          | A OR B                                      |   .
!  |__________________________|________________________         ____________|   .
!                             |                        |       |                .
!                             |          ..............|.......|.............   .
!                             |          : .------.    |       |            :   .
!                             |          : | NAND |    |       |            :   .
!                             |          : '------'  _---_   _---_          :   .
!                    (A OR B) |AND (A NAND B)        |   v   |   v          :   .
!                             +------------------+---'   '---'   '----[Gnd] :   .
!                             |          :       ;                          :   .
!                             |          :..................................:   .
!                             |                                                 .
!                            {Y} = A XOR B                                      .
!                                                                               .

If you want to create {XNOR}, just add a NOT to the Output

!  |                          | A OR B                                      |   .
!  |__________________________|________________________         ____________|   .
!                             |                        |       |                .
!                             |          ..............|.......|.............   .
!                             |          : .------.    |       |            :   .
!                             |          : | NAND |    |       |            :   .
!                             |          : '------'  _---_   _---_          :   .
!                    (A OR B) |AND (A NAND B)        |   v   |   v          :   .
!                             +------------------+---'   '---'   '----[Gnd] :   .
!                             |          :       ;                          :   .
!                             |          :..................................:   .
!                             |                                                 .
!                             +----------------.                                .
!                             |                |                                .
!            .................|.............   |                                .
!            : .-----.     (A)|            :   |                                .
!            : | NOT |        |            :   |                                .
!            : '-----'      _---_          :   |                                .
!            :              |   v          :   |                                .
!            : [+V]--*--+---'   '----[Gnd] :   |                                .
!            :          |                  :   |                                .
!            :..........|..................:   |                                .
!                       |                      |                                .
!                      {Y} = A XNOR B         {Y'} = A XOR B                    .
!                                                                               .

And, as a bonus, we get to keep {XOR} !


~~~~ ,-------------------.                                                      .
~~~ (  A Human Interface  ) ====================================================.
~~~~ `-------------------'                                                      .

Right
...We now have all the Lego Bricks we need to build a computer.

...We understand how to make these Bricks out of phsyical switches
...And we understand how to make them out of electronic switches
...In fact, with some lateral thinking,
   you can make switches, and therefore Gates, out of pretty much anything:
      # water pipes      : https://www.youtube.com/watch?v=IxXaizglscw
      # marbles          : https://www.youtube.com/watch?v=TTK-vcwSm7s
      # car relays       : https://www.youtube.com/watch?v=e8DavnWmr1E
      # Minecraft blocks : https://www.youtube.com/watch?v=IOoy_eG8efI
      # Valves           : https://www.youtube.com/watch?v=s7nx-pMQ6tM

   But computers made of marbles, in deference to their true awesomeness,
   tend to be very /very/ big ...and are (in honesty) a bit crap.
   ...So let's stick with transistors for now.

~-~ Human Interface  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

A Human Interface is going to be rather critical, so let's design one...

We need an input device, and an output device.

For the {Input}s, we are going to need a
	"Human-Action" to an "Electronic-Signal" converter
...Ie. A "Keyboard"

~-~ The Keyboard ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

Let's take a simple "NOT" Gate, and add a Human Input Device ("HID")

(o) A Random (NOT) Gate                                                         .
!                                                                               .
!                    (A)                                                        .
!            NOT      |                                                         .
!                   _---_                                                       .
!                   |   v                                                       .
!     [+V]--*--+----'   '-----------------[Gnd]                                 .
!              |                                                                .
!              |                                                                .
!             {Y}                                                               .
!                                                                               .

If we connect { A -> [+V] }, that is equivalent to { Pressing  } the switch
If we connect { A -> Gnd  }, that is equivalent to { Releasing } the switch

If A is {+V,  Pressed } we say A is {1, High, True,  On,  Set,   Enabled,  ...}
If A is {Gnd, Released} we say A is {0, Low,  False, Off, Reset, Disabled, ...}

The simple/obvious method is to use a "Single Pole, Double Throw" (SPDT) switch
...this will typically be a toggle switch, or slide switch
...But three drawing pins and a paperclip are equally as valid

You will need one human-to-electronic switch converter for each input...

(o) SPDT Input Mechanism                                                        .
!                                                                               .
!                [Gnd]  [+V]                                                    .
!                  |     |                                                      .
!                  |    |#|                                                     .
!                  |    |#|          <--- Current Limiting Resistor             .
!                  |    |#|                                                     .
!                  |     |                                                      .
!          Release o\    o Press                                                .
!             0      \       1       <--- Toggle switch (SPDT)                  .
!                     o                                                         .
!                     |                                                         .
!                     |                                                         .
!.....................|..........................................................
!                     |                                                         .
!                    (A)                                                        .
!             NOT     |                                                         .
!                   _---_                                                       .
!                   |   v                                                       .
!     [+V]--*--+----'   '-----[Gnd]                                             .
!              |                                                                .
!              |                                                                .
!              |                                                                .
!             {Y}                                                               .
!                                                                               .

The alternative is a "Single Pole, Single Throw, Push-to-Make" (SPST/PtM) switch
These are often the little "tact" switches that are ubiquitous (and cheap)

But they're a bit trickier to wire up ...You need to either:
    a) Learn about voltage dividers, and transistor switching thresholds
OR  b) Just take my word for it

You will need ONE {SPST/PtM} "tact" switch and TWO resistors
	# One of the resistors should be at least 4.7K
	  ...This is "big enough" to stop things {getting hot / melting /exploding}
	# The other will need to be at least 4x as big as the first one ...because!
      ...I choose 10K and 100K ...I've got some of those in a bag somewhere!

Smaller resistors : Faster switching speed [*] ; more power consumption
Larger  resistors : Slower switching speed     ; less power consumption

[*] For what we are doing, switching speed is going to be of ZERO relevance

(o) SPST Input Mechanism                                                        .
!                                                                               .
!                Press to "make" switch                                         .
!                     (SPST/PtM)                                                .
!                                                                               .
!                          |                                                    .
!                        __V__                                                  .
!     [+V]----[###]-------o o----+----[###]---[Gnd]                             .
!              10K               |     100K                                     .
!                                |                                              .
!................................|...............................................
!                                |                                              .
!                               (A)                                             .
!                        NOT     |                                              .
!                              _---_                                            .
!                              |   v                                            .
!                [+V]--*--+----'   '-----[Gnd]                                  .
!                         |                                                     .
!                         |                                                     .
!                         |                                                     .
!                        {Y}                                                    .
!                                                                               .

When the switch is "open",
  {A} is connected to {Gnd} through a (large) "Pull-Down" resistor

When the switch is "closed"
  electricity comes in from {+V} ...via a Current Limiting Resistor
  then has to make a choice of going via:
      a) the (large) resistor ...to {Gnd}
	  b) straight to the switch input

...In our over-simplified model, the 'path of least resistance' wins.

Both/Either method(s) will meet our needs ...Your choice
...Probably based on what randon components you have in your 'bits box'

~-~ More input controls  ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

In reality (AND 'thought-experiment' world) you can use what you like:
	# A normal switch (SPDT)
	# Thermostat
	# Infra-red receiver (demodulator)
	# Door sensor (reed switch)
	# A massive water wheel
	# Some lemons, some zinc strips, and some copper strips
	# A dynamo
...Go wild

~-~ The Output Display ~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

This is not actually as easy as you might think!

To use an LED, you need a [you guessed it] current limiting resistor.

(o) LED with Current Limiting Ressitor                                          .
!                                                                               .
!               ,,                                                              .
!    ----[###]-|>|---                                                           .
!                                                                               .

You need quite a lot of electricity to create photons,
so that resistor will need to be quite small
...For now, let's say: "about 100 ohms"

(o) Output LED - Wrong                                                          .
!                                                                               .
!     NOT            (A)                                                        .
!                     |                                        WRONG            .
!                   _---_                                                       .
!                   |   v                                                       .
!     [+V]--*--+----'   '----------[Gnd]                                        .
!              |                                                                .
!              |          ,,                                                    .
!             {Y}------*-|>|-------[Gnd]                                        .
!                                                                               .

But. If you follow the path from {+V}, via the LED, to {Gnd}
you will pass TWO resistors, and that first one will be (likely 10+) *Kilo* ohms
...So that pathway has 10,100 ohms of resistance - that is a LOT more than 100

Do you remember, right back where we started, with the lightbulb circuit?

(o) That lightswitch again!                                                     .
!                                              _                                .
!                                             (~)                               .
!                   __V__                      #                                .
!     [+V]-----------o o---------------------[###]----------[Gnd]               .
!                                                                               .

This is our solution!

Lets update reaplce the {Switch + Lightbulb} with a {Transistor + LED}

(o) Electronic lightswitch                                                      .
!                                                                               .
!     BUFFER                  {A}                                               .
!                              |                                                .
!                            _---_                                              .
!                     ,,     |   |                                              .
!     [+V]---[###]---|>|-----'   '------[Gnd]                                   .
!                                                                               .

See how ONE resistor is used to limit the current to both
 the LED, and the Transistor

So...

(o) Output LED                                                                  .
!                                                                               .
!            .............................................                      .
!            :                                           :                      .
!            : NOT                   (A)                 :                      .
!            :                        |                  :                      .
!            :                      _---_                :                      .
!            :                      |   v                :                      .
!            : [+V]---[###]----+----'   '----------[Gnd] :                      .
!            :         10K     |                         :                      .
!            :                 |                         :                      .
!            :                {Y}                        :                      .
!            :.................|.........................:                      .
!                              |                                                .
!   ...........................|..........................                      .
!   : DISPLAY                 {A}                        :                      .
!   :  (1 mono pixel)          |                         :                      .
!   :                        _---_                       :                      .
!   :                 ,,     |   |                       :                      .
!   : [+V]---[###]---|>|-----'   '-----------------[Gnd] :                      .
!   :         100                                        :                      .
!   :....................................................:                      .
!                                                                               .

If you make 1080 * 1920 (ie. 2,073,600) of these
and you make them REALLY small (or stand a LONG way away)
...you now know how to build a Monochrome Hi-Def TV screen :)

Multiply that by 4 (Red, Green, Green, Blue} (8,294,400)
...now you have a Full Colour Hi-Def TV screen

~-~ An Input Display ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

Although this might seem like an insane idea, it is a great learning tool!

If we put LEDs on the INPUTS of each gate,
we can literally WATCH how the data moves around.

Let's use the 1-switch NOT gate to demonstrate this:

(o) A Random Gate (NOT)                                                         .
!                                                                               .
!     NOT                       (A)                                             .
!                                |                                              .
!                                |                                              .
!                                |                                              .
!                              _---_                                            .
!                              |   v                                            .
!     [+V]---[###]---------+---'   '----------[Gnd]                             .
!             10K          |                                                    .
!                          |                                                    .
!                         {Y}                                                   .
!                                                                               .

(o) A Random Gate (NOT) with Input LED                                          .
!                                                                               .
!     NOT (with Input LED)      (A)                                             .
!                                |                                              .
!                     ,,         |                                              .
!     [+V]---[###]---|>|---.     |                                              .
!             100          |   _---_                                            .
!                          |   |   v                                            .
!     [+V]---[###]---------+---'   '----------[Gnd]                             .
!             10K          |                                                    .
!                          |                                                    .
!                         {Y}                                                   .
!                                                                               .

When the trasistor is turned on {A = 1}, it completes the pathway
between {+V} and {Gnd} for *both* the NOT gate *and* the LED

If we want the LED better in line-up with the actual input,
we can just swivel it around!

(o) A Random Gate (NOT) with Input LED (rotated)                                .
!                                                                               .
!     NOT (with Input LED)      (A)                                             .
!                                |                                              .
!                              _---_                                            .
!                              |   v                                            .
!     [+V]---[###]---------+---'   '----------[Gnd]                             .
!             10K          |                                                    .
!                          |                                                    .
!                          +----|<|---[###]---[+V]                              .
!                          |           100                                      .
!                          |                                                    .
!                         {Y}                                                   .
!                                                                               .


~~~~ ,--------------.                                                           .
~~~ (  AT LONG LAST  ) =========================================================.
~~~~ `--------------'                                                           .

We have all the Gates we need
We have A keyboard
We have a Display

Now all we need is a computer...

~~~~ ,-----------.                                                              .
~~~ (  Adding up  ) ============================================================.
~~~~ `-----------'                                                              .

At the start I said you MUST understand counting in Binary.
For this section, you need to be able to count to 2 : {00 .. 01 .. 10}

So let's do something useful with these gates...

Let's atart small, and just add up TWO 1-digit numbers

Computers count using Binary. So we only have to consider 0 and 1

The so called "HALF ADDER" will add up two 1-bit numbers
  and present the result as {Sum & Carry}

(o) Adding two 1-bit numbers to get a 2-bit result                              .
!                                                                               .
!      :  0+0 = 0  :  0+1 = 1  :  1+0 = 1  :  1+1 = 2  :                        .
! .....:...........:...........:...........:...........:                        .
!	A  :     0     :     0     :     1     :     1     :                        .
!	B  :     0 +   :     1 +   :     0 +   :     1 +   :                        .
!	   :    ==     :    ==     :    ==     :    ==     :                        .
!	   :    00     :    01     :    01     :    10     :                        .
|      :           :           :           :           :                        .
|      :    ^^     :           :           :           :                        .
!	        ||                                                                  .
!	        |`-- Sum                                                            .
!	        `--- Carry                                                          .
!                                                                               .

Let's draw out the "Sum" bit as a Truth Table:

(o) Truth Table for Half-Adder SUM bit                                          .
!                                                                               .
!	A :  0        0        1        1                  | A | B |  Sum  |        .
!	B :  0 +      1 +      0 +      1 +                +----+--+-------+        .
!	    ==       ==       ==       ==                  | 0 | 0 |   0   |        .
!	    00       01       01       10                  | 0 | 1 |  =1=  |  XOR   .
!	     |        |        |        |                  | 1 | 0 |  =1=  |        .
!	     ^--------^--------^--------^--- Sum bit       | 1 | 1 |   0   |        .
!                                                                               .

And repeat that for the Carry bit:

(o) Truth Table for Half-Adder CARRY bit                                        .
!                                                                               .
!	A :  0        0        1        1                  | A | B | Carry |        .
!	B :  0 +      1 +      0 +      1 +                +----+--+-------+        .
!	    ==       ==       ==       ==                  | 0 | 0 |   0   |        .
!	    00       01       01       10                  | 0 | 1 |   0   |  AND   .
!	    |        |        |        |                   | 1 | 0 |   0   |        .
!	    ^--------^--------^--------^--- Carry bit      | 1 | 1 |  =1=  |        .
!                                                                               .

Hopefully you can see the    "Sum" bit  is the result of an  {XOR}  operation
                  and the  "Carry" bit  is the result of an  {AND}  operation

Let's build it...

(o) Half Adder pocket reference (with gates)                                    .
!                                                                               .
!             +-----.                                                           .
!      ,------|      \                                                          .
!      |      |       }--- CARRY        | |                     (AND)  (XOR)    .
!      |  ,---|      /                 _|_|_          | A | B | Carry | Sum |   .
!  A---+  |   +-----'                 | A B |         +----+--+-------+-----+   .
!      |  |                        ---<C Î£  |         | 0 | 0 |   0   |  0  |   .
!  B---{--+                           |__S__|         | 0 | 1 |   0   | =1= |   .
!      |  |  . +--._                     |            | 1 | 0 |   0   | =1= |   .
!      |  `---\ \   `-.                  |            | 1 | 1 |  =1=  |  0  |   .
!      |       ) }    ,'--- SUM                                                 .
!      `------/ /  _,'                                                          .
!            ' +--'                                                             .
!                                                                               .
!   if  ((A == 1) && (B == 1))  then  {CARRY=1}  else  {CARRY=0}                .
!   if  ((A == 1) ^  (B == 1))  then  {SUM=1}    else  {SUM=0}                  .
!                                                                               .

That was easy!

~~~~ ,--------------------------.                                               .
~~~ (  Adding up longer numbers  ) =============================================.
~~~~ `--------------------------'                                               .

For this section, you need to be able to count to 3 : {00 .. 01 .. 10 .. 11}
...Advanced stuff, hey?

But what if we want to add a TWO digit number?

The second (and subsequent) digits will NEED to
  consider any Carry generated by the first (/previous) digit

Out of the 16 possible sums...

(o) The 16 sums you need to know                                                .
!                                                                               .
!    | A | B | Cin |   Math    | Binary | Cout | Sum |                          .
!    |-------------|-----------|--------|------------|                          .
!    | 0 | 0 |  0  | 0+0+0 = 0 |   00   |  0   |  0  |                          .
!    | 0 | 0 |  1  | 0+0+1 = 1 |   01   |  0   |  1  |                          .
!    | 0 | 1 |  0  | 0+1+0 = 1 |   01   |  0   |  1  |                          .
!    | 0 | 1 |  1  | 0+1+1 = 2 |   10   |  1   |  0  |                          .
!    |   |   |     |           |        |      |     |                          .
!    | 1 | 0 |  0  | 1+0+0 = 1 |   01   |  0   |  1  |                          .
!    | 1 | 0 |  1  | 1+0+1 = 2 |   10   |  1   |  0  |                          .
!    | 1 | 1 |  0  | 1+1+0 = 2 |   10   |  1   |  0  |                          .
!    | 1 | 1 |  1  | 1+1+1 = 3 |   11   |  1   |  1  |                          .
!                                                                               .

...these four cover all the edge cases:

(o) The Edge Cases                                                              .
!                                                                               .
!	(3 + 3 = 6) : Top & Bottom bits carry -------------------------.            .
!	                                                               |            .
!	(2 + 2 = 4) : Top bit carries --------------------.            |            .
!	                                                  |            |            .
!	(1 + 1 = 2) : Bottom bit carries ------.          |            |            .
!	                                       |          |            |            .
!	(0 + 1 = 1) : No carry  ---.           |          |            |            .
!                              |           |          |            |            .
!	                           |           |          |            |            .
!	                          /|           |          |           /|            .
.	                          ''           '          '           ''            .
!	                A -->     00          01          10          11            .
!	                B -->     01 +        01 +        10 +        11 +          .
.	       Carry data -->                 1          1           11             .
!	                         ===         ===         ===         ===            .
!	           Result -->    001         010         100         110            .
!	                         ===         ===         ===         ===            .
.                            ^^^                                                .
!                            ||!   ,-------------------------------------.      .
!                            ||!   | Digit |   value   | name            |      .
!                            ||!   |-------|-----------|-----------------|      .
!                            ||`---|  #0   | (2^0 = 1) | first  / bottom |      .
!                            |`----|  #1   | (2^1 = 2) | second / top    |      .
!                            `-----|  #2   | (2^2 = 4) | third  / carry  |      .
!                                  `-------------------------------------'      .
!                                                                               .

For Digit #1 [the second didgit from the right] (and subsequent digits)
we need an extra input for the "Carry" (from the previous digit)
...A so called "FULL ADDER"

That is:
    As well as   a CARRY going  OUT of the Adder (for  the   next   bit)
    We will have a CARRY coming IN  to the Adder (from the previous bit)

We have already shown:  {A} + {B}          => {C}    , {S}      [Half Adder]

Now we need to infer:   {A} + {B} + {C.in} => {C.out}, {S}      [Full Adder]

~~~~ ,------------.                                                             .
~~~ (  Full Adder  ) ===========================================================.
~~~~ `------------'                                                             .


We have already worked out the first HALF of the ADDER problem:
	.-----------------------.
	| HALF  |     OUTPUT    |
	| ADDER | (AND) | (XOR) |
	| A | B | CARRY |  SUM  |
	+----+--+-------+-------+
	| 0 | 0 |   0   |   0   |
	| 0 | 1 |   0   |  =1=  |
	| 1 | 0 |   0   |  =1=  |
	| 1 | 1 |  =1=  |   0   |
	'-----------------------'

The 2nd half of the FULL ADDER is an identical HALF ADDER

This (2nd) HALF ADDER also has TWO Inputs:
	      One Input is the SUM       from the first HALF ADDER
	The other Input is the CARRY.out from the previous Full Adder

(o) Building a Full Adder (using gates)                                         .
!                                                                               .
!                +-----.                               +-----.                  .
!         ,------|      \  H.Carry              ,------|      \  H.Carry        .
!         |      |       }---->                 |      |       }---->           .
!         |   ,--|      /                       |   ,--|      /                 .
!   A >---+   |  +-----'       ,----------------+   |  +-----'                  .
!         |   |                |                |   |                           .
!         |   |                |                |   |                           .
!         |   |                |                |   |                           .
!   B >---{---+                |   Carry.In>----{---+                           .
!         |   |  . +--._       |                |   |  . +--._                  .
!         |   `---\ \   `-.    |                |   `---\ \   `-.               .
!         |        ) }    ,'---'                |        ) }    ,'---> SUM      .
!         `-------/ /  _,'  H.Sum               `-------/ /  _,'                .
!                ' +--'                                ' +--'                   .
!                                                                               .

This diagram is getting needlessly big.

We've been going to a lot of effort to invent Symbols for everything we create.

We invented a symbol for Half Adder, let's use it.

(o) Rotated Half Adder                                                          .
!                                                                               .
!              | |                                                              .
!             _|_|_                  ,-------.                                  .
!            | A B |    <--.       -->B      |                                  .
!         ---<C Î£  |        `.       |   Î£  S>--                                .
!            |__S__|         |     -->A  C   |                                  .
!               |                    `---v---'                                  .
!               |                                                               .
!                                                                               .

(o) Building a Full Adder (using two Half Adders)                               .
!                                                                               .
!            ,-------.                                                          .
!       B --->B      |         ,-------.                                        .
!            |   Î£  S>--------->B      |                                        .
!       A --->A  C   |         |   Î£  S>--- SUM                                 .
!            `---v---'  C.in--->A  C   |                                        .
!                |             `---v---'                                        .
!                |                 |                                            .
!               {c1}              {c2}                                          .
!                                                                               .

That will give us the final SUM
But we have TWO ways that might cause a CARRY  ( {c1} and {c2} )

We can say:
	IF   the 1st Half Adder causes a Carry {c1}
	{OR} the 2nd Half Adder causes a Carry {c2}
	THEN we need to output a Carry {Carry.out = 1}

ie. If  ({c1} OR {c2})  then  ({Carry.Out} = 1)    ... else  ({Carry.Out} = 0)

So we can 'glue' the two Half Adders together with an {OR} gate...

(o) Full Adder (made from Half Adders)                                          .
!                                                                               .
!            ,-------.                                                          .
!       B --->B      |         ,-------.                                        .
!            |   Î£  S>--------->B      |                                        .
!       A --->A  C   |         |   Î£  S>-------- SUM                            .
!            `---v---'    .---->A  C   |                                        .
!                |        |    `---v---'                                        .
!    C.in -------{--------'        |      _                                     .
!                |                 `-----\ `.___ CARRY.out                      .
!                `-----------------------/_,'                                   .
!                                                                               .

QUESTIONS:
	Would this work if we used an {XOR} gate instead of an {OR} gate?
		If so:  Why didn't we use an {XOR} gate?
		If not: Why not?

Here is a working one to play with:
https://www.falstad.com/circuit/circuitjs.html?ctz=CQAgjCAMB0l3BWK0wGZUA4BsCsHYAmAFlQVUgE4iDwKQkT6BTAWjDACgwEjwsQSNDJAGoaImkgRcEIsPwKEQwkIvGqo9DgHc+qjBhBsFBqDqPyBl4yEy9I5mwVM27Z3ZYK4jWXl-4OAMoWRLxEFPwsBJCG4QGaAGYAhgA2AM5MmgQcAEpG0bEqUcQCKiIiRCJI5cjSAOb5MfRgNMW8CC2aDg1RTeS8bbaQ9mZ5vYZq+SWTNZX0XbUcwWyh+obja5oQyemZEhw9BQJwU2En5bmNhqhY6wQlN4azVQsw0stgq24bbjU7GVkOAAPfKyVRUfKoPwUPACVS8ACCwNBNFQFAgURutghfl4ACFkVE8KgBBQ6JiILIaLiQABhaAASwAdlwsJJnLQaFgmmAKDQaAATJjJACuKQALiwUkwBeBXrBOPJ2bExCBuSr+SAhaKJVKZXKajBIJwGurOWqSrz1N01U1BBawqqLiCyPwwHgqhQSe6STT6QB7EXi5E8X1NBB8qwQGmBEUAW0c8hE6EikxT7gs3NErUm9ocumMVSzRMkWfzmYkcxL8IuBc+vG+ll+if4REsljbAXMHaI618Al7GZY-dCfb8pnLw-HY9U3kn9c2U825aTmyOzie5nXpnXc63dsH283ug3A4mB+Ps9bnlMnYzC7c-lsGHsW533l3XZPH-f-Gb3+vBRvH-Ndf2XGQJB3JRSH5JQJE0aRuGnbNbAQaknQ0KRzBUe12HQ8Ru06XDOhg+8vhfcBVjiIcF2o2iIjMbhqXbSNezkSN4KqbCJCUPDVDgwjYJoPj3S-cBOlEqw3TwMTSLTCiZnMR9oIUppy0fO1PDUwTUOErNT3LNiUNIvMOAAI3NXlrnwAQ8GqcyjDwOheToBiiBkswLLYTpcDCCgkE+ElyzQwwrVKdiCN0EKUKM0yQRYOzVC8cAJA5XgwEMAAJVIEgAHTSBEBSFAAnZFolS-kMCQe4GHALKcvywqSsJMATnkSIMr4Oh0sMAAxMUUkaoqmFKkFGDYa4TjYWrOsgfLcoAB3yua0kW-KwHm1aAEd1vy6B9vygBvNJ43WgAafKAGMkmK4qAE9loAX2RRgkHIERYjqqB5qWtINtW36Vvmna-r2g60mO06-outJrtuh60kgZ6xpJcghmTX0vqB37-rW0HVu2-KCDB6AjpOuNlphuH7vW5GBEkaqyXoT7OtxwGfuWzbcpB-79tJiHyfOq6bppxG6eoEAnPBOgMGpL62c5gHdoJ7miZJsmocgKmRYRsBxe9SBUbayBW3ljn8bxoHCbSYm0j5jWKcR7X4dpl7vWS97wDSs2lYtnGuZB1B1YFqGwGd0W9Ze1o22loxMDhWbzexxXgcV+2Q8drXhZdsWXvWFQ0AGPBYR6kAES5tI8Qr+lmWRDKSRYFRFHWYuE8MWNHc2gMg27SJ+3TJcHCAA


~~~~ ,-----------------.                                                        .
~~~ (  Brevity is King  ) ======================================================.
~~~~ `-----------------'                                                        .

Give the Full Adder a symbol

(o) Full Adder pocket reference                                                 .
!                                                                               .
!                             FULL ADDER                                        .
!                                                | A | B | C | CARRY |  SUM  |  .
!            |   |                               +----+---+--+-------+-------+  .
!      ,-----v---v----.                          | 0 | 0 | 0 |   0   |   0   |  .
!      |     A   B    |           _|_|_          | 0 | 1 | 0 |   0   |  =1=  |  .
!      |              |          | A B |         | 1 | 0 | 0 |   0   |  =1=  |  .
!    --< C.out Î£ C.in <--      --<C Î£ c<--       | 1 | 1 | 0 |  =1=  |   0   |  .
!      |              |          |__S__|         |   |   |   |       |       |  .
!      |      Sum     |             |            | 0 | 0 | 1 |   0   |  =1=  |  .
!      `-------v------'                          | 0 | 1 | 1 |  =1=  |   0   |  .
!              |                                 | 1 | 0 | 1 |  =1=  |   0   |  .
!                                                | 1 | 1 | 1 |  =1=  |  =1=  |  .
!                                    _                                          .
!                   ,---------------\|`.___                                     .
!              __   |       __   .--/_,'   |                                    .
!    A>--+----|& \__| +----|& \__|         `---> Co = (A & B) | ((A ^ B) & Ci)  .
!    B>--{-+--|__/    | ,--|__/                                                 .
!   Ci>--{-{----------{-+                  .---> S  = (A ^ B) ^ Ci              .
!        | |    _   ,-+ |    _             |                                    .
!        | `--\\^`._| | `--\\^`.___________|                                    .
!        `----//_,'   `----//_,'                                                .
!                                                                               .

In the Truth Table, you can see:
	If there are an ODD number of 1's,   SUM=1  (...else   SUM=0)
	If there is     > 1           1's, CARRY=1  (...else CARRY=0)


~~~~ ,----------------------------.                                             .
~~~ (  Even ASCII has limitations  ) ===========================================.
~~~~ `----------------------------'                                             .

In the next section we will needd a symbol for "to the power of"

This is clasically achieved by writing the "power" number in superscript
...This is nigh-impossible in ASCII

Eg. TWO "to the power of" SEVEN

      ###   ###
     #   #    #
        #    #         == 2 * 2 * 2 * 2 * 2 * 2 * 2 == 128
       #
      #
     #####


ALSO:
	We're using a single circumflex/pointy-hat to mean {XOR} (eg. 11 ^ 01 == 10)
	...so we can't use notation such as "2^7" either!

Therefore, I will use the notation "^^" to mean "to the power of"

Eg.   2^^7 == (2 x 2 x 2 x 2  x  2 x 2 x 2) == 128


~~~~ ,--------------------------.                                               .
~~~ (  Adding up longer numbers  ) =============================================.
~~~~ `--------------------------'                                               .

WARNING:
	To complete this section you need to know all the binary numbers
	from {0..15}, or should I say {0000..1111}

Let's use our new "FULL ADDER" to do some adding up

We'll start with a 2-bit number,
...so we will need TWO Full Adders

Eg. 01 + 01 == 10

NB. "bits" are numbered from  <right-to-left<
                      and we  start counting at 0  (...not 1)

(o) qv. "Required Knowledge : How Binary works"                                 .
!                                                                               .
!                          43210 <------bit number                              .
|                          '''''        |                                       .
|   Binary Number -->  ....10101     ,--'                                       .
|      (Base 2)            |||||     |      ___value___                         .
!                          |||||     |                                          .
!                          ||||`---  0   .. (2^^0) ==  1                        .
!                          |||`----  1   .. (2^^1) ==  2                        .
!                          ||`-----  2   .. (2^^2) ==  4                        .
!                          |`------  3   .. (2^^3) ==  8                        .
!                          `-------  4   .. (2^^4) == 16                        .
!                                    :   ..  ::::  == ::                        .
!                                                                               .

We are adding up a 2-digit number, so we will need 2 Adders
For reasons that will become apparent later, we will only use FULL Adders.

(o) A pair of Adders                                                            .
!                                                                               .
!		       _|_|_     _|_|_                                                  .
!		      | A B |   | A B |                                                 .
!		[V]---<C Î£ c<---<C Î£ c<---0                                             .
!		      |__S__|   |__S__|                                                 .
!		         |         |                                                    .
!                                                                               .

Using the "2^^N" details above, let's index each of those Adders

...Start on the {Right},  start at {#0}

(o) A pair of indexed Adders                                                    .
!                                                                               .
!               | |       | |                                                   .
!		       _|_|_#1   _|_|_#0     <---Adder index {..., #1, #0}              .
!		      | A B |   | A B |                                                 .
!		[V]---<C Î£ c<---<C Î£ c<---0                                             .
!		      |__S__|   |__S__|                                                 .
!		         |         |                                                    .
!                                                                               .

Bear in mind, if our result is {4, 5, or 6} the left-most/"top" bit will
overflow and set its Carry.Out to 1 ...and this data [datum] will be lost.

Most CPUs actually store this "overflow" in a "Flag" called "oVerflow"

~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .

Okay ...let's put some values in to this circuit...

A = 01   and   B = 01

	# The digits of "A" go to the  A  inputs
	# The digits of "B" go to the  B  inputs

	# The  right-most  digit goes in to the  right-most  Adder
	# The   left-most  digit goes in to the   left-most  Adder

(o) 2-bit Full Adder - wroking example                                          .
!                                                                               .
|                       A: 01                    <------.                       .
!                    _____/  \____                      |                       .
!                   |             |                     |                       .
|                   |   B: 01     |              <------}------.                .
!                   |  ___/  \____|_                    |      |                .
!                   | |           | |                   |      |                .
!                   | |           | |                   |      |                .
|                   0 0           1 1                 <-+    <-+                .
!                   | |           | |                   |      |                .
!		           _|_|_#1       _|_|_#0         __     |      |                .
!		          | A B |       | A B |            `.   |      |                .
!		[V]---(0)-<C Î£ c<---(1)-<C Î£ c<---0         :---}---.  |                .
!		 |        |__S__|       |__S__|             ,   |   |  |                .
!		 |           |             |             --'    |   |  |                .
|		[0]         [1]           [0]                   |\  |  |\               .
!        |           |             |                    ''  '  ''               .
!        |           |             |                    01  +  01 == 010        .
!        |           |             |                                 |_/        .
!        `-----------`-------------`---------------------------------'          .
!                                                                               .
																		        .

The Sum for Adder #0 == 0 ------.
The Sum for Adder #1 == 1 -----.|
.                              ||
.                              ||
So the answer to :  01 + 01 == 10    ...   1 + 1 = 2

...There was no overflow


~~~~ ,---------------------------.                                              .
~~~ (  Adding up Massive numbers  ) ============================================.
~~~~ `---------------------------'                                              .

Hopefully you have realised you can daisy chain as many of these as you like
...mostly based on how many transistors you have laying around
...ever wondered why we don't have 128bit CPUs (yet)? ...Well now you know!

Let's add up a 4 digit number...

	1100 + 0110 == 1'0010
	 12  +   6  ==   18

First we'll put all the bits from  A  on the  A  inputs of the Adders

(o) 4-bit Adder : Load the A inputs                                             .
!                                                                               .
|                                     A=1100                                    .
!                  ____________________/ || \_______________                    .
!                 |                      ||                 |                   .
!                 |              _______/  \__              |                   .
!                 |             |             |             |                   .
!                 |             |             |             |                   .
|                 1             1             0             0                   .
!                 | |           | |           | |           | |                 .
!                _|_|_#3       _|_|_#2       _|_|_#1       _|_|_#0              .
!               | A B |       | A B |       | A B |       | A B |               .
!     [V]-------<C Î£ c<---(.)-<C Î£ c<---(.)-<C Î£ c<---(.)-<C Î£ c<---0           .
!               |__S__|       |__S__|       |__S__|       |__S__|               .
!                  |             |             |             |                  .
!                                                                               .

Then we'll put all the bits from  B  on the  B  inputs of the Adders

(o) 4-bit Adder : Load the B inputs                                             .
!                                                                               .
|                                     B=0110                                    .
!                    __________________/ || \_________________                  .
!                   |              _____/  \______            |                 .
!                   |             |               |           |                 .
!                   |             |               |           |                 .
!                   |             |               |           |                 .
|                   |             |   A=1100      |           |                 .
!                  _|_____________|____/ || \_____|_________  |                 .
!                 | |             |      ||       |         | |                 .
!                 | |            _|_____/  \__  ,-'         | |                 .
!                 | |           | |           | |           | |                 .
!                 | |           | |           | |           | |                 .
|                 1 0           1 1           0 1           0 0                 .
!                 | |           | |           | |           | |                 .
!                _|_|_#3       _|_|_#2       _|_|_#1       _|_|_#0              .
!               | A B |       | A B |       | A B |       | A B |               .
!     [V]-------<C Î£ c<---(.)-<C Î£ c<---(.)-<C Î£ c<---(.)-<C Î£ c<---0           .
!      |        |__S__|       |__S__|       |__S__|       |__S__|               .
!      |           |             |             |             |                  .
!      1           0             0             1             1                  .
!                                                                               .

Now follow the logic from  <right-to-left<

(o) 4-bit Adder : Perform the maths                                             .
!      :          : :           : :           : :           : : :               .
!      :          A B c         A B c         A B c         A B c       SUM     .
!      :          : :           : :           : :           : : :               .
|      :          : :           : :           : :       #0  0+0+0               .
!      :          : :           : :           : :          c=0,s=0              .
!      :          : :           : :           : : v----------/   \------> 0     .
|      :          : :           : :       #1  0+1+0                       :     .
!      :          : :           : :          c=0,s=1                      :     .
!      :          : :           : : v----------/   \-------------------> 1:     .
|      :          : :       #2  1+1+0                                    ::     .
!      :          : :          c=1,s=0                                   ::     .
!      :          : : v----------/   \--------------------------------> 0::     .
|      :      #3  1+0+1                                                 :::     .
!      :         c=1,s=0                                                :::     .
!      v-----------/   \---------------------------------------------> 0:::     .
!      1                                                               ::::     .
!      \-------------------------------------------------------------. ::::     .
!  !overflow!                                                        : ::::     .
!                                                       !overflow!   1'0010     .
!                                                                               .

Serious-nerd question [do not try this!]...
	Assuming 10nS propogation on all transistors
	How long does our 4-bit Adder take to produce a result?

(o) 4-bit Adder : Review the result                                             .
!                                                                               .
!	The Sum for Adder #0 == 0 ------------.                                     .
!	The Sum for Adder #1 == 1 -----------.|                                     .
!	The Sum for Adder #2 == 0 ----------.||                                     .
!	The Sum for Adder #3 == 0 ---------.|||                                     .
!	.                                  ||||                                     .
!	.                                  ||||                                     .
!	So the answer to :  1100 + 0110 == 0010                                     .
!	Ie.                  12  +  6   ==   2    ...oh dear ...out by 16           .
!                                                                               .

BUT ...we had an oVerflow!

This overflow was trying to get to the "Carry.In" of the non-existent Adder #4
...but, instead, probably ended up in Flag.oVerflow

IF Adder #4 (the 5th adder) had existed,
it would have had the value (2^4 == 16)
...Curiously, the exact amount of our error ;)


~~~~ ,---------------------.                                                    .
~~~ (  Counting in Circles  ) ==================================================.
~~~~ `---------------------'                                                    .

Let's look closer at what happened in that overflow error...

We only had a 4-bit Adder, so:
	the MINimum value was 0000 ...(aka "00" in human-friendly decimal)
	the MAXimum value was 1111 ...(aka "15" in human-friendly decimal)

Let's write those numbers down in a circle...

(o) 4-bit Counting Circle                                                       .
!                                                                               .
!       Carry.Out                                                               .
!		      \00      \    +1                                                  .
!		    15    01    \ |                                                     .
!		  14        02   \|                                                     .
!		 13          03        If you add      1 (+1), you move      clockwise  .
!		12            04       If you subtract 1 (-1), you move anti-clockwise  .
!		 11          05                                                         .
!		  10        06  /|                                                      .
!		    09    07   / |                                                      .
!		       08     /     -1                                                  .
!                                                                               .

So 14 +1  -> 15
   15 +1  -> 00  <---** [carry out: overflow]
   00 +1  -> 01

** As we pass from 15 to 0, a "carry out" occurs, and we set the Flag.oVerflow

The same would work in reverse:

So 01 -1  -> 00
   00 -1  -> 15  <---** [carry out: underflow]
   15 -1  -> 14

** As we pass from 0 to 15, a "carry out" occurs, and we set the Flag.unDerflow

How does this help us solve our dilemma?
	12 + 6  = 18    <-- correct answer
	12 + 6  =  2    <-- calcualted answer (wrong)

Start on the number circle at 12, and do "+1" 6 times:-
	(12+1=13)    12 +1  -> 13
	(12+2=14)    13 +1  -> 14
	(12+3=15)    14 +1  -> 15
	(12+4=16)    15 +1  -> 00  <--- [carry out: overflow]
	(12+5=17)    00 +1  -> 01
	(12+6=18)    01 +1  -> 02  <=-- Result

So our result is "2, with an overflow"

Examples:
	Anything with a total > 15
		15 +  1  ->  0  *oVerflow
		14 +  2  ->  0  *oVerflow
		11 +  5  ->  0  *oVerflow
		 8 +  8  ->  0  *oVerflow

		12 +  9  ->  5  *oVerflow
		 8 + 10  ->  2  *oVerflow

	Anything with a total < 0
		 1 -  2  -> 15  *unDeflow
	 	 4 -  5  -> 15  *unDeflow
		 9 - 10  -> 15  *unDeflow
		14 - 15  -> 15  *unDeflow

		 5 -  9  -> 12  *unDeflow
		 7 - 15  ->  8  *unDeflow

Just remember:
	When you reach the highest number your Adder can store, you go back at 0
	...et vice verse

This is also known as:
	# Modulo maths        [favoured by programmers]
	# Remainder maths     [what I learned when I was in primary school]
	# Galois field theory [crypto nerds can be ponces sometimes]


~~~~ ,----------------.                                                         .
~~~ (  Consumer Chips  ) =======================================================.
~~~~ `----------------'                                                         .

A 4-bit Full Adder could be quite handy.

In fact they sell them, the 74LS83 is one such example
	...74 is the chip range
	...LS means Low Speed
	...83 is a "4 bit full adder"

The Block Symbol is classically:

(o) 4-Bit Adder : Block Diagram                                                 .
!                                                                               .
!	          A   B                                                             .
!	        |||| ||||                                                           .
!	      ,-vvvv-vvvv-.                                                         .
!	      | 3210 3210 |                                                         .
!	Cout--<     Î£     <--Cin                                                    .
!	      |  3 2 1 0  |                                                         .
!	      `--v-v-v-v--'                                                         .
!	         | | | |                                                            .
!	            S                                                               .
!                                                                               .

The Circuit Symbol would also include "+V" and "Gnd" pins

Why are +V/Gnd not on the Block Symbol?  ...For brevity
	It is a symbol for an electronic chip
	If you don't feed it electrons, it won't "chip" for you
	So the presence of {+V} and {Gnd} are generally "assumed"


~~~~ ,------------------.                                                       .
~~~ (  8-Bit Full Adder  ) =====================================================.
~~~~ `------------------'                                                       .

If we create an 8-bit Full Adder, we will have an adder big enough to hold
a BYTE of information.  That's any value in the range {0 .. 255}

Let's just glue TWO 4-bit Adders together

(o) 8-Bit Adder using two 4-bit Adders                                          .
!                                                                               .
!	        A.Hi B.Hi       A.Lo B.Lo                                           .
!	        |||| ||||       |||| ||||                                           .
!	      ,-vvvv-vvvv-.   ,-vvvv-vvvv-.                                         .
!	      | 3210 3210 |   | 3210 3210 |                                         .
!	Cout--<     Î£     <---<     Î£     <--Cin                                    .
!	      |  3 2 1 0  |   |  3 2 1 0  |                                         .
!	      `--v-v-v-v--'   `--v-v-v-v--'                                         .
!	         | | | |         | | | |                                            .
!	            S               S                                               .
!                                                                               .

NB. This is one reason why we don't use a Half-Adder for bit-0
    Full Adders make it easy to make chips that can be daisy-chained!

I do not know of any readily available 8-bit Adders
...probably limited demand just due to sheer size

	 8 pins for A
	 8      for B
	 8      for S
	 2      for Cin/Cout
	 2      for +V/Gnd
	==
	28 pins required (+Clock, +ChipEnable, +..., +...)

(o) 8-bit Adder : Block Diagram (of a theoretical chip)                         .
!                                                                               .
!	        ,--A---. ,--B---.                                                   .
!	        |||||||| ||||||||                                                   .
!	      ,-vvvvvvvv-vvvvvvvv-.                                                 .
!	      | 76543210 76543210 |                                                 .
!	Cout--<         Î£         <--Cin                                            .
!	      |  7 6 5 4 3 2 1 0  |                                                 .
!	      `--v-v-v-v-v-v-v-v--'                                                 .
!	         | | | | | | | |                                                    .
!	         `------S------'                                                    .
!                                                                               .

But again, already, this Symbol is starting to get big,
so let's make it smaller

(o) N-bit Adder : pocket reference                                              .
!                                                                               .
!	         |  |                                                               .
!	      ,--M--M--.                                                            .
!	      |  A  B  |           '8' (bus width) is written in the centre         .
!	Cout--<Co  8 Ci<--Cin                                                       .
!	      |  Î£ S   |              'v'    ->   'M'                               .
!	      `----M---'           (one bit)    (a bus - of the specified width)    .
!	           |                                                                .
!                                                                               .


~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ .

Let's stop and think about what we've got here...
	# We've got EIGHT "Full Adders"

	# Each Full Adder is made from:
		(2 * AND)  -->                            (2 * NOT) + (1 * NOR )
		(1 * OR )  -->                            (2 * NOT) + (1 * NAND)
		(2 * XOR)  -->  (1 * OR) + (1 * NAND) --> (2 * NOT) + (2 * NAND)

	# Totalling:
		(6 * NOT )  .. 6 * (1 transistor)  == 6
		(1 * NOR )  .. 1 * (2 transistors) == 2
		(3 * NAND)  .. 3 * (2 transistors) == 6

	# So each Full Adder is/may-be made from 14 transistors

	8 Full Adders * 14 transistors = 112 transistors in total

...And you COMPLETELY understand EXACTLY how it all works

You now know how to take 112 transistors and (with some time & patience)
    you could BUILD an 8-bit computer that will execute
	the machine code instruction: `ADD X, Y`


~~~~ ,-------.                                                                  .
~~~ (  Recap  ) ================================================================.
~~~~ `-------'                                                                  .

In the first section we learned all about how to make gates from transistors.

In this (second) section we have been putting those gates together
in such a way that we can add up two numbers of any size.

We have:
	# built two types of Adder:
		# Half Adder {(XOR, AND)                }, 2 gates   6 transistors
		# Full Adder {(XOR, AND), (XOR, AND), OR}, 5 gates, 14 transistors

	# designed symbols for these "Adder" modules

	# daisy chained  2  Full Adders to add up a  2  digit number
	# daisy chained  4  Full Adders to add up a  4  digit number

	# learned about circular counting

	# discovered the real-world "4 bit adder" chip (74LS83)

	# created a theoretcial "8 bit adder" chip


~~~~ ,----------.                                                               .
~~~ (  Going Up  ) =============================================================.
~~~~ `----------'                                                               .

While we're inventing useful Modules.

Humans do a lot of simple "counting" {1, 2, 3, 4, ...}
	# for i = 1 to 100 step 1
	# length = (end-start) + 1
	# entry = array_index + 1
	# etc.

Let's create a bespoke Adder which simply does "+1"
...You'll see why shortly ;)

We could use a Full adder:
	# "A" can be supplied by the user
	# "B" can be fixed as the value 0001
	# force the "Carry.in" of Bit-0 to be 0

OR .. We could:
	# "A" can be supplied by the user
	# "B" can be fixed as the value 0000
	# force the "Carry.in" of Bit-0 to be 1

...we would get the same Output

However, if we use the Carry.in method,
the user can choose whether to set Carry.In to either 1 or 0
and therefore could toggle it between a +0, and a +1 adder.

...you might ask "why would you EVER want a +0 adder"
...for now: Trust me; all will become clear ;)

~-~~  ,-------------.    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .   .
~-~~ (  Incrementor  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ .
~-~~  `-------------'    `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `   .

What happens if we take a Full Adder and force B=0

              .----------------.    .----------------.    .----------------.
              |  XOR  | OUTPUT |    |  AND  | OUTPUT |    |  OR   | OUTPUT |
              | A | B |   Y    |    | A | B |   Y    |    | A | B |   Y    |
              +----+--+--------+    +----+--+--------+    +----+--+--------+
  aid         | 0 | 0 |   0    |    | 0 | 0 |   0    |    | 0 | 0 |   0    |
memoire -->   | 0 | 1 |  =1=   |    | 0 | 1 |   0    |    | 0 | 1 |  =1=   |
              | 1 | 0 |  =1=   |    | 1 | 0 |   0    |    | 1 | 0 |  =1=   |
              | 1 | 1 |   0    |    | 1 | 1 |  =1=   |    | 1 | 1 |  =1=   |
              '----------------'    '----------------'    '----------------'

Let's start with a Full Adder:-

(o) Full Adder : 5 gates                                                        .
!                                                                               .
!                                                        +--._                  .
!                           .-----------------------------\   `-.               .
!                           |                              }    ,'--- CARRY     .
!               +-----.     |            +-----.     ,----/  _,'                .
!         ,-----|      \    |     ,------|      \    |   +--'                   .
!         |     |       }---'     |      |       }---'                          .
!         |  ,--|      /          |   ,--|      /                               .
!    A >--+  |  +-----'           |   |  +-----'                                .
!         |  |                    |   |                                         .
!         |  |    Carry.in >------{---+                                         .
!         |  |                    |   |                                         .
!    B >--{--+                ,---+   |                                         .
!         |  |  . +--._       |   |   |  . +--._                                .
!         |  `---\ \   `-.    |   |   `---\ \   `-.                             .
!         |       ) }    ,'---'   |        ) }    ,'---> SUM                    .
!         `------/ /  _,'         `-------/ /  _,'                              .
!               ' +--'                    ' +--'                                .
!                                                                               .

.	                                                   | A | B |  XOR   |
.	bottom-left XOR gate ...what happens when B=0      | 0 | 0 |   0    |
.	                     ...we get Y = A               | 1 | 0 |  =1=   |

(o) Reduce the {XOR}, of the first Half Adder, to {A}                           .
!                                                                               .
!                                                        +--._                  .
!                           .-----------------------------\   `-.               .
!                           |                              }    ,'--- CARRY     .
!               +-----.     |            +-----.     ,----/  _,'                .
!         ,-----|      \    |     ,------|      \    |   +--'                   .
!         |     |       }---'     |      |       }---'                          .
!         |  ,--|      /          |   ,--|      /                               .
!    A >--+  |  +-----'           |   |  +-----'                                .
!         |  |                    |   |                                         .
!         |  |    Carry.in >------{---+                                         .
!         |  |                    |   |                                         .
!    B >--{--'                ,---+   |                                         .
!         |                   |   |   |  . +--._                                .
!         |                   |   |   `---\ \   `-.                             .
!         `-------------------'   |        ) }    ,'---> SUM                    .
!                                 `-------/ /  _,'                              .
!                                         ' +--'                                .
!                                                                               .

.	                                                   | A | B |  AND   |
.	top-left AND gate    ...what happens when B=0      | 0 | 0 |   0    |
.	                     ...we get Y = 0               | 1 | 0 |   0    |

(o) Reduce the {AND}, of the first Half Adder, to {0}                           .
!                                                                               .
!                                                        +--._                  .
!                           .-----------------------------\a  `-.               .
!                           |                              }    ,'--- CARRY     .
!                           |            +-----.     ,----/b _,'                .
!                           |     ,------|      \    |   +--'                   .
!                    0 >----'     |      |       }---'                          .
!                                 |   ,--|      /                               .
!    A >--+                       |   |  +-----'                                .
!         |                       |   |                                         .
!         |       Carry.in >------{---+                                         .
!         |                       |   |                                         .
!         |                   ,---+   |                                         .
!         |                   |   |   |  . +--._                                .
!         |                   |   |   `---\ \   `-.                             .
!         `-------------------'   |        ) }    ,'---> SUM                    .
!                                 `-------/ /  _,'                              .
!                                         ' +--'                                .
!                                                                               .

Now we have the OR gate on the right
...One of its inputs is now "always 0"

.	                                                   | a | b |  OR    |
.	top-right OR gate    ...what happens when a=0      | 0 | 0 |   0    |
.	                     ...we get Y = b               | 0 | 1 |   1    |
.

(o) Reduce the {OR} to {B}                                                      .
!                                                                               .
!                                                         .---------- CARRY     .
!                                        +-----.          |                     .
!                                 ,------|      \         |                     .
!                                 |      |       }--------'                     .
!                                 |   ,--|      /                               .
!    A >--+                       |   |  +-----'                                .
!         |                       |   |                                         .
!         |       Carry.in >------{---+                                         .
!         |                       |   |                                         .
!         |                   ,---+   |                                         .
!         |                   |   |   |  . +--._                                .
!         |                   |   |   `---\ \   `-.                             .
!         `-------------------'   |        ) }    ,'---> SUM                    .
!                                 `-------/ /  _,'                              .
!                                         ' +--'                                .
!                                                                               .

Which leaves us with just TWO gates

The second "half-adder" that made the original "Half Adder" up to a "Full Adder"

The OR gate is gone because it is only required to glue the two halves together

All we have really achieved is to rename "B" to "Carry.In"

But we're starting to look at the Process of Simplifyng Logic
...WITHOUT learning about "Karnaugh Maps"

https://www.allaboutcircuits.com/textbook/digital/chpt-8/logic-simplification-karnaugh-maps/

We need a symbol for this 1-bit "+1" module :

(o) 1-bit Incrementor                                                           .
!                                                                               .
!            |                                                                  .
!         ,--v--.                                                               .
!         !  A+1|                                                               .
!         <C   c<--1                                                            .
!         !  S  |                                                               .
!         `--v--'                                                               .
!            |                                                                  .
!                                                                               .

As with the Full Adder, we can daisy-chain these to make an N-bit "+1" module

(o) N-bit Incrementor                                                           .
!                                                                               .
!            |  #N-1    :          :          |  #1      |  #0                  .
!         ,--v--.    ,- - -.    ,- - -.    ,--v--.    ,--v--.                   .
!         !  A+1|    :     :    :     :    !  A+1|    !  A+1|                   .
!  [v]----<C   c<----:     :----:     :----<C   c<----<C   c<----1              .
!         !  S  |    :     :    :     :    !  S  |    !  S  |                   .
!         `--v--'    `- - -'    `- - -'    `--v--'    `--v--'                   .
!            |          :          :          |          |                      .
!                                                                               .

And following the same convention as before, we can pick a Symbol

(o) N-bit Incrementor                                                           .
!                                                                               .
!            |                                                                  .
!         ,--M--.         We use an "M" rather than a "v"                       .
!         !  A+1|            to imply this is a 'multi-wire' "bus"              .
!         <C 4 c<--1           not a 'single-wire' "bit"                        .
!         !  S  |                                                               .
!         `--M--'          The "4" indicates that the "bus width" is 4-bits     .
!            |                                                                  .
!                                                                               .

Or, if preferred, we can allow the user to use "Carry.in" as an "Enable" pin
	If C.in = 1, the unit performs +1  ...ie. ENabled
	If C.in = 0, the unit performs +0  ...ie. DISabled

We might even rename the pin on the diagram to something more helpful...

(o) N-bit Incrementor : Bit-0 Carry.in used as an ENable pin                    .
!                                                                               .
!	         |                                                                  .
!	      ,--M--.                                                               .
!	      !  A+1|                                                               .
!	      <C 4 e<--      e : enable                                             .
!	      !  S  |                                                               .
!	      `--M--'                                                               .
!	         |                                                                  .
!                                                                               .

~-~ Yes, but what have I really ahieved? ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~.

In assembl[er|y] / machine-code/language
	this is (commonly) known as the INC instruction
	...This is the circuit which fires when you do `INC A`

You have just created, from first principles,
another assembler instruction using only transistors!

What CPU instructions do we have so far?
```
	NOT    x        ; x = ~(  x  )

	AND    x, y     ; x =  (x & y)
	NAND   x, y     ; x = ~(x & y)

	OR     x, y     ; x =  (x | y)
	NOR    x, y     ; x = ~(x | y)

	XOR    x, y     ; x =  (x ^ y)
	XNOR   x, y     ; ...did you manage to make this one?

	ADD    x, y     ; x =  (x + y)

	INC    X        ; x = x + 1
```

~~~~ ,------------------------.                                                 .
~~~ (  Something to Take Away  ) ===============================================.
~~~~ `------------------------'                                                 .

OK. So we can add up.
What about other fancy mathematical functions like "taking away"?

There are (at least) two (probably dozens of) ways to approach this problem
...Each (probably) has its own cost/benefit.

We COULD repeat the Full Adder exercise, and design the "Full Subtractor"
	https://www.geeksforgeeks.org/full-subtractor-in-digital-logic/

It wouldn't be a bad way to practice your new skillz  <~hint, hint~>

  --- OR ---

We could use a maths trick and (electronically) simplify the problem ;)

Let's start simple (carefully chosen) problem:
	7 - 3 = 4

What does that look like in Binary?
	A =  0111
	B =  0011 -
	     ====
	     0100

But we only have an ADDER !

We have:                    7  -   3  ==   4
This is the same as:      (+7) - (+3) == (+4)
It is also the same as:   (+7) + (-3) == (+4)
.                              ^
.                              |
.                              '---------------.
.                                               \_____
And we have managed to turn the problem in to an Adder problem !

But, inevitably, we have a new problem ... we need to convert +3 to -3

Another way of thinking of  -3  is:  (0 - 3)

Remember this counting circle?

(o) 4-bit Counting Circle                                                       .
!                                                                               .
!        Carry                                                                  .
!             \00      \    +1                                                  .
!           15    01    \ |                                                     .
!         14        02   \|                                                     .
!        13          03            If you +1, you move      clockwise           .
!       12            04           If you -1, you move anti-clockwise           .
!        11          05                                                         .
!         10        06  /|                                                      .
!           09    07   / |                                                      .
!              08     /     -1                                                  .
!                                                                               .

...Let's do (0 - 3) that on the number-circle
	 0 - 1 = 15
	   - 2 = 14
	   - 3 = 13

So, as a 4-bit value, -3 is actually represented by the value 13

Let's try that:
	(+7) + (-3) == (+4)

	(+7) + (13) == ____

	Decimal   Binary
.	 7        0111
.	13 +      1101 +
.	          ----
.	         1111   (carry)
.	====    / ====
.	 4     |  0100  (result)
.	       |
.	       '---- Carry.out

The result is 0100, which is indeed 4  ... (7 + 13 == 4)

It got the right answer!
...It ALSO generates a Carry.out
...but we generated it moving (clockwise) from 15..0
...{15..0}/clockwise "oVerflows" are only relevant during ADDITION
...So we will (for now) just ignore it

So:
	7 - (+3) == 4
	7 + (-3) == 4
	7 + (13) == 4, with a Carry.out/oVerflow, which we ignore

(o) 4-bit Counting Circle (with negative numbers)                               .
!                                                                               .
!      Carry.out                                                                .
!            \__00__                                                            .
!          _-'\     `-_                                                         .
!         /    \00      \      \    +1                                          .
!       -1   15    01   -15     \ |                                             .
!     -2   14        02  -14     \|                                             .
!    -3   13          03  -13           add      1 (+1) :  move      clockwise  .
!   -4   12            04  -12          subtract 1 (-1) :  move anti-clockwise  .
!    -5   11          05  -11                                                   .
!     -6   10        06  -10     /|                                             .
!       -7   09    07   -9      / |                                             .
!         \_    08    _/       /     -1                                         .
!           -.__  __.-                                                          .
!               -8                                                              .
!                                                                               .


~-~~ ,------------------------------.    .  .  .  .  .  .  .  .  .  .  .  .  .  .
~-~ (  Complementary My Dear Watson  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~ .
~-~~ `------------------------------'    `  `  `  `  `  `  `  `  `  `  `  `  `  .

The final question remains:

What gates can you use to convert
	(eg) "3" to "-3" ... where "-3" is represented as "13" (on a 4-bit Adder)

Look at these numbers in binary

		 3 :  0011  <-- starting point
		13 :  1101  <-- ending point

If you ran enough examples, you WOULD eventually spot the pattern.

Feel free to STOP HERE and try to work it out...
	   |   0  |  -1  |  -2  |  -3  |  -4  |  -5  |  -6  |  -7  |  -8  |  -9  |
--------------------------------------------------------------------------------
Before | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |
After  | 0000 | 1111 | 1110 | 1101 | 1100 | 1011 | 1010 | 1001 | 1000 | 0111 |

Did you crack it?
	"Invert/NOT all the bits, and add one (+1)"

		 3 :  0011  <-- starting point
		      1100  <-- NOT all the bits
		      1101  <-- +1
		13 :  1101  <-- ending point

How do you NOT a bit? ...You use a NOT gate!

(o) NOT pocket reference                                                        .
!                                                                               .
!	    |`.                                                                     .
!	    |  `.  _                                            |   A   |   Y   |   .
!	A---|    `(_)---Y         NOT           ---|>o---       +-------+-------+   .
!	    |   .'                "IS NOT"                      |   0   |  =1=  |   .
!	    | .'                                                |   1   |   0   |   .
!       |'                                                                      .
!                   if  (A == 1)  then  {Y=0}  else  {Y=1}                      .
!                                                                               .

How do you NOT 4 bits?  ...4 NOT gates!

(o) 4-bit Inverter                                                              .
!                                                                               .
!       0011 (+3)                                                               .
!       ||||                                                                    .
!       |||`---[1]---|>o---[0]------.                                           .
!       ||`----[1]---|>o---[0]-----.|                                           .
!       |`-----[0]---|>o---[1]----.||                                           .
!       `------[0]---|>o---[1]---.|||                                           .
!                                ||||                                           .
!                                1100  (12)                                     .
!                                                                               .

How do you +1 ? ...With the "+1" module we just created

(o) N-bit Incrementor : Bit-0 Carry.in used as an ENable pin                    .
!                                                                               .
!            |                                                                  .
!         ,--M--.                                                               .
!         !  A+1|                                                               .
!         <C 4 e<--      e : enable                                             .
!         !  S  |                                                               .
!         `--M--'                                                               .
!            |                                                                  .
!                                                                               .

Let's glue them together:-

(o) 2's Complement module                                                       .
!                                                                               .
!       0011  (+3)                                                              .
!       ||||                                                                    .
!       |||`---[1]---|>o---[0]------.                                           .
!       ||`----[1]---|>o---[0]-----.|                                           .
!       |`-----[0]---|>o---[1]----.||                                           .
!       `------[0]---|>o---[1]---.|||                                           .
!                                ||||                                           .
!                               [1100]  (12)                                    .
!                                ||||                                           .
!                                |:;/                                           .
!                                \M/                                            .
!                                 M                                             .
!                                 M                                             .
!                                 M                                             .
!                                 M                                             .
!                              ,--M--.                                          .
!                              !  A+1|                                          .
!                           X--<C 4 e<--- 1                                     .
!                              !  S  |                                          .
!                              `--M--'                                          .
!                                 M                                             .
!                                 M                                             .
!                                /M\                                            .
!                                |::\                                           .
!                                ||||                                           .
!                               [1101]  (13)                                    .
!                                                                               .

This operation is known as a "twos complement" ...No idea why "\_o_/"

This is very common in computer maths, so let's invent a symbol for it

(o) 2's Complement module Symbol                                                .
!                                                                               .
!      |                                                                        .
!   +--M--+   <-- M       : as many inputs as the bus is wide                   .
!   |  A  |                                                                     .
!   |  4  |   <-- bus is    4 bits wide                                         .
!   | 2's |   <-- function: 2's complement                                      .
!   +--M--+   <-- M       : as many outputs as the bus is wide                  .
!      |                                                                        .
!                                                                               .


~~~~ ,----------------------------.                                             .
~~~ (  Take it Away From Me - NOW  ) ===========================================.
~~~~ `----------------------------'                                             .

So far we have:
	# built a "+1" module
	# added some NOT gates to the inputs
	# drawn a box around it all
	# and called it a "2's complement" module (aka "2's")

We did some "circular" maths and learned that
	in a 4-bit machine, "-3" is represented by the value "13"

The way you get from -3 rto 13 is
	2s(-3) --> 13   ... "Flip all the bits, and add 1"

Now we can finally solve our subtraction problem!
	We started with:            7  -   3  ==   4
	This is the same as:      (+7) - (+3) == (+4)
	It is also the same as:   (+7) + (-3) == (+4)
	perform 2's(-3):          (+7) + (13) == (+4)

(o) 4-bit Subtactor (using an Adder and 2's module)                             .
!                                                                               .
!	        A     B                                                             .
!	        |     |                                                             .
!	        |     |                                                             .
!	        |  +--M--+                                                          .
!	        |  |  '  |                                                          .
!	        |  |  4  |                                                          .
!	        |  | 2's |                                                          .
!	        |  +--M--+                                                          .
!           `,    |                                                             .
!	         |  ,-'                                                             .
!	         |  |                                                               .
!	      ,--M--M--.                                                            .
!	      |  A  B  |                                                            .
!	Cout--<Co  4 Ci<--0                                                         .
!	      |    S   |                                                            .
!	      `----M---'                                                            .
!	           |                                                                .
!	           |                                                                .
!	         (A-B)                                                              .
!                                                                               .


~~~~ ,-------------.                                                            .
~~~ (  The Enabler  ) ==========================================================.
~~~~ `-------------'                                                            .

So we have an ADDER module and a SUBTRACTOR module

(o) 4-bit Adder and Subtractor                                                  .
!                                                                               .
!	       (A  +  B)                    (A  -  B)                               .
!	        |     |                      |     |                                .
!	        |     |                      |     |                                .
!	        |     |                      |  +--M--+                             .
!	        |     |                      |  |  '  |                             .
!	        |     |                      |  |  4  |                             .
!	        |     |                      |  | 2's |                             .
!	        |     |                      |  +--M--+                             .
!           `,    |                      `,    |                                .
!	         |  ,-'                       |  ,-'                                .
!	         |  |                         |  |                                  .
!	      ,--M--M--.                   ,--M--M--.                               .
!	      |  A  B  |                   |  A  B  |                               .
!	Cout--<Co  4 Ci<--0          Cout--<Co  4 Ci<--0                            .
!	      |    S   |                   |    S   |                               .
!	      `----M---'                   `----M---'                               .
!	           |                            |                                   .
!	           |                            |                                   .
!	         (A-B)                        (A-B)                                 .
!                                                                               .

If we had some way of switching the 2's Complemnt module on/off
we could use the second circuit for BOTH "Add" and "Subtract"

Let's revisit the 2's Complement Logic Diagram...

(o) 2's Complement module                                                       .
!                                                                               .
!    0011  (+3)                                                                 .
!    ||||                                                                       .
!    |||`---[1]---|>o---[0]------.                                              .
!    ||`----[1]---|>o---[0]-----.|                                              .
!    |`-----[0]---|>o---[1]----.||                                              .
!    `------[0]---|>o---[1]---.|||                                              .
!                             ||||                                              .
!                            [1100]  (12)                                       .
!                             ||||                                              .
!                             |:;/                                              .
!                             \M/                                               .
!                              M                                                .
!                              M                                                .
!                              M                                                .
!                              M                                                .
!                           ,--M--.                                             .
!                           !  A+1|                                             .
!                        X--<C 4 e<--- 1    <--- Enable                         .
!                           !  S  |                                             .
!                           `--M--'                                             .
!                              M                                                .
!                              M                                                .
!                             /M\                                               .
!                             |::\                                              .
!                             ||||                                              .
!                            [1101]  (13)                                       .
!                                                                               .

We've already designed the "+1" unit to have an 'enable' pin
	# If 'e' is 1,  the +1 unit performs "+1"  ...ie ENabled
	# If 'e' is 0,  the +1 unit performs "+0"  ...ie DISabled


~-~~ ,---------------------------.    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
~-~ (  What About the NOT gates?  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~ .
~-~~ `---------------------------'    `  `  `  `  `  `  `  `  `  `  `  `  `  `  .

The NOT gates are still going to flip all the bits
So we need to get that Enable line to ALSO enable/disable the NOT gates

	,-----------------------.
	|   A    |  B  |   Y    |
	| enable | bit | output |
	+--------|-----|--------+ - - - - - - - - - - - - - - - - - - - - -
	|   0    |  0  |   0    |  NOT isn't Enabled, bit stays the same
	|   0    |  1  |  =1=   |
	|- - - - |- - -| - - - -| - - - - - - - - - - - - - - - - - - - - -
	|   1    |  0  |  =1=   |  NOT  is   Enabled, bit    inverts
	|   1    |  1  |   0    |
	'-----------------------' - - - - - - - - - - - - - - - - - - - - -

Where have we seen that Logic Table before?

(o) XOR pocket reference                                                        .
!                                                                               .
!	    . +--._                                             | A | B |   Y   |   .
!	A----\ \   `-.                               _          +----+--+-------+   .
!	      ) }    ,'---Y       XOR/EOR       ---\\ `.___     | 0 | 0 |   0   |   .
!	B----/ /  _,'                           ---//_,'        | 0 | 1 |  =1=  |   .
!	    ' +--'                                              | 1 | 0 |  =1=  |   .
!                                                           | 1 | 1 |   0   |   .
!                                                                               .
!   if  ((A ^ B) == 1)  then  {Y=1}  else  {Y=0}                                .
!                                                                               .

So if we simply rename the Input froms {A, B} rto {enable, bit}
  we can use an "XOR gate" as a "NOT gate with an Enable line"

Let's redraw the 2's complement diagram, and
use XOR gates instead of NOT gates for the bit flipping

(o) 2's Complement module with {Enable} Input                                   .
!                                                                               .
!    3210                                                                       .
!    ||||   .------------------------------,                                    .
!    ||||   |           _                  |                                    .
!    ||||   +---[e]---\\ `._____           |                                    .
!    |||`---{---[0]---//_,'     `.         |                                    .
!    |||    |           _        |         |                                    .
!    |||    +---[e]---\\ `.____  |         |                                    .
!    ||`----{---[1]---//_,'    `.|         |                                    .
!    ||     |           _       ||         |                                    .
!    ||     +---[e]---\\ `.___  ||         |                                    .
!    |`-----{---[2]---//_,'   `.||         |                                    .
!    |      |           _      |||         |                                    .
!    |      `---[e]---\\ `.__  |||         |                                    .
!    `----------[3]---//_,'  `.|||         |                                    .
!                             ||||         |                                    .
!                             ||||         |                                    .
!                             |:;/         |                                    .
!                             \W/          |                                    .
!                              M           |                                    .
!                              M           |                                    .
!                              M           |                                    .
!                           ,--M--.        |                                    .
!                           !  A+1|        |                                    .
!                        X--<C 4 e<--------+--- Enable                          .
!                           !  S  |                                             .
!                           `--M--'                                             .
!                              M                                                .
!                              M                                                .
!                             /W\                                               .
!                             |::\                                              .
!                             ||||                                              .
!                             3210                                              .
!                                                                               .

And, of course, create a symbol for our new
	"2's complement with enable line" module

(o) 2's Complement module with {Enable} Input - Symbol                          .
!                                                                               .
!      |                                                                        .
!	+--M--+                                                                     .
!	|  A  |                                                                     .
!	|  4 e<--           Bus width (eg. "4" bits)                                .
!	| 2's |             2's Commplement                                         .
!	+--M--+                                                                     .
!      |                Output = (~Input) +1                                    .
!                                                                               .


~-~~ ,-----------------------------.    .  .  .  .  .  .  .  .  .  .  .  .  .   .
~-~ (  All In One Adder/Subtractor  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ .
~-~~ `-----------------------------'    `  `  `  `  `  `  `  `  `  `  `  `  `   .

We now have a Full Subtractor, made with only
	1 * (4bit) Full Adder
	1 * (4bit) Half Adder
	4 * XOR (NOT-with-enable)

Remember:
	Whether we are doing `ADD` or `SUB`
	the "Bit #0 Carry.In" of the Full Adder MUST, ALWAYS be 0

But, consider this:
	2's Complement does: (INVERT(A) +1)
	If we set the Full Adder's "Bit #0 Carry.In" to 1,
	...we would effetively be adding ANOTHER 1
	...and end up adding (INVERT(A) +1 +1)

(o) Full Adder/Subtractor module                                                .
!                                                                               .
!  B =  3210                                                                    .
!       ||||   .------------------------------,                                 .
!       ||||   |           _                  |                                 .
!       ||||   +---[e]---\\ `._____           |                                 .
!       |||`---{---[0]---//_,'     `.         |                                 .
!       |||    |           _        |         |                                 .
!       |||    +---[e]---\\ `.____  |         |                                 .
!       ||`----{---[1]---//_,'    `.|         |                                 .
!       ||     |           _       ||         |                                 .
!       ||     +---[e]---\\ `.___  ||         |                                 .
!       |`-----{---[2]---//_,'   `.||         |                                 .
!       |      |           _      |||         |                                 .
!       |      `---[e]---\\ `.__  |||         |                                 .
!       `----------[3]---//_,'  `.|||         |                                 .
!                                ||||         |                                 .
!                                |:;/         |                                 .
!  A =  1100                     \M/          |                                 .
!       \::/                      M           |                                 .
!         M                       M           |                                 .
!         M                    ,--M--.        |                                 .
!         M                    !  A+1|        |    Subtract                     .
!         M                 X--<C 4 e<--------+--- Enable                       .
!         M                    !  S  |                                          .
!         M                    `--M--'                                          .
!         M                       M                                             .
!         MMMMMMMMMMMMMMM         M                                             .
!                       M         M                                             .
!                       M  MMMMMMMM                                             .
!                       M  M                                                    .
!                       M  M                                                    .
!                    ,--M--M--.                                                 .
!                    |  A  B  |                                                 .
!              Cout--<Co  4 Ci<------------------- 0   <--- MUST BE 0           .
!                    |  Î£ S   |                                                 .
!                    `----M---'                                                 .
!                         |                                                     .
!                                                                               .

Have you spotted what I'm about to do?

We seem to have TWO mechanisms that will allow us to do "+1"

	# The one in the 2's Complement module
	  ...ie. the dedicated "+1" module

	# And another effective "+1" in to the Full Adder
	  ...ie. the effect of setting "Carry.In" to 1

We are doing basic maths, so we are kinda OBLIGED to keep the Full Adder.
...which comes with a free "+1" feature (normally used for daisy-chaining)
...which we, *explicitly*, ALWAYS set to 0 / Disabled

It is possible to simplify (reduce the cost) of our "Adder/Subtractor", if we:
	# Remove the "+1" box (inside the 2's Complement module)
	# Use the "+1" feature of the Full Adder!
      ...Ie. when we are in SUBTRACT mode

(o) Full Adder/Subtractor module - reduced complexity                           .
!                                                                               .
!  B =  3210                                                                    .
!       ||||   .------------------------------,                                 .
!       ||||   |           _                  |                                 .
!       ||||   +---[e]---\\ `._____           |                                 .
!       |||`---{---[0]---//_,'     `.         |                                 .
!       |||    |           _        |         |                                 .
!       |||    +---[e]---\\ `.____  |         |                                 .
!       ||`----{---[1]---//_,'    `.|         |                                 .
!       ||     |           _       ||         |                                 .
!       ||     +---[e]---\\ `.___  ||         |                                 .
!       |`-----{---[2]---//_,'   `.||         |                                 .
!       |      |           _      |||         |                                 .
!       |      `---[e]---\\ `.__  |||         |                                 .
!       `----------[3]---//_,'  `.|||         |                                 .
!                                ||||         |                                 .
!                                |:;/         |                                 .
!  A =  1100                     \M/          |                                 .
!       \::/                      M           |                                 .
!        `M                       M           |    Subtract      0 : Add        .
!         M                       M           +--- Enable        1 : Subtract   .
!         MMMMMMMMMMMMMMM         M           |                                 .
!                       M         M           |                                 .
!                       M  MMMMMMMM           |                                 .
!                       M  M                  |                                 .
!                    ,--M--M--.               |                                 .
!                    |  A  B  |               |                                 .
!              Cout--<Co  4 Ci<---------------'                                 .
!                    |  Î£ S   |                                                 .
!                    `----M---'                                                 .
!                         |                                                     .
!                                                                               .

...Yes. Apparently it is VERY easy to simplify it!

I don't want to keep on drawing those "enabled NOT" (ie. XOR) Gates

Let's create a symbol for an "Inverter" module

(o) Inverter - Symbol                                                           .
!                                                                               .
!      |                                                                        .
!	+--M--+                                                                     .
!	|  A  |                                                                     .
!	|  4 e<--           Bus width (eg. "4" bits)                                .
!	|  ~  |             ~ Inverter                                              .
!	+--M--+                 Output = (~Input)                                   .
!      |                                                                        .
!                                                                               .


(o) Full Adder/Subtractor module - block diagram                                .
!                                                                               .
!   A: 3210    B: 3210                                                          .
!      \::/       \::/                                                          .
!       `M         `M                                                           .
!        M          M                                                           .
!        M       +--M--+                                                        .
!        M       |  A  |                                                        .
!        M       |  4 e<---.                                                    .
!        M       |  ~  |   |                                                    .
!        M       +--M--+   |                                                    .
!        M          M      |                                                    .
!        MMMMM      M      +--- Subtact                                         .
!            M  MMMMM      |     Enable                                         .
!            M  M          |                                                    .
!         ,--M--M--.       |                                                    .
!         |  A  B  |       |                                                    .
!       --<Co  4 Ci<-------'                                                    .
!         |  Î£ S   |                                                            .
!         `----M---'                                                            .
!              |                                                                .
!                                                                               .

By adding only 1 "enabled-NOT" [*] gate (aka "XOR" gate) to each "bit" of {B}
...we have converted our "Full Adder" to a "Full Adder/Subtractor"

[*] NB. Each "Enbled-NOT"/"XOR" gate costs 6 transistors

We've invented another Module ...Time to invent another Symbol

(o) Adder/Subtractor pocket reference                                           .
!                                                                               .
!                           ADDER/SUBTRACTOR                                    .
!                                                                               .
!            |   |                                                              .
!      ,-----v---v----.                                                         .
!      |     A   B    |           _|_|_                                         .
!      |              |          | A B |                                        .
!    --< C.out Î£   Sub<--      --<C Î£ S<---  if (S == 0)                        .
!      |              |          |__R__|     then  R = A + B                    .
!      |     Result   |             |        else  R = A - B                    .
!      `-------v------'                                                         .
!              |                                                                .
!                                                                               .
!                                                                               .



~~~~ ,-----------------.                                                        .
~~~ (  Nothing is Free  ) ======================================================.
~~~~ `-----------------'                                                        <

We started with a separate Adder & Subtractor
		                  Transistor cost (N = number of bits)
	# Adder               ------------------------------------
		# 1 Full Adder     N * 14
	# Subtractor
		# 1 Inverter       N *  6
		# 1 Incrementor    N *  8
		# 1 Full Adder     N * 14   == N * 42     [[ @8=336  @64=2688 ]]
_____________________________________________________________________________
Then we simplified the Subtractor (by using Carry.In instead of Incrementor)
	# Adder
		# 1 Full Adder     N * 14
	# Subtractor
		# 1 Inverter       N *  6
		# {1 Incrementor}  {XXX}
		# 1 Full Adder     N * 14   == N * 34     [[ @8=272  @64=2176 ]]
_____________________________________________________________________________
Then we realised how to use the Subtractor as an Adder/Subtractor
	# Adder
		# {1 Full Adder}   {XXX}
	# Subtractor
		# 1 Inverter       N *  6
		# {1 Incrementor}  {XXX}
		# 1 Full Adder     N * 14   == N * 20     [[ @8=160  @64=1280 ]]
_____________________________________________________________________________
Leaving us with
	# Adder/Subtractor
		# 1 Inverter       N *  6
		# 1 Full Adder     N * 14   == N * 20     [[ @8=160  @64=1280 ]]

...On a 64 bit machine, we just saved (2688 - 1280 = 1,408) transistors

So we just reclaimed MORE THAN 50% of the space on our silicon/breadboard.

You don't get a saving like that for free ...So. What's the catch?

The first, obvious cost is:
	When we had an Adder and a Subtractor
		we could do two sums at the same time
	Now we have a combined Adder/Subtractor
		we can only do one sum at any given time

That's only a 50% speed loss, and we have >50% saving
...But overall, we're still up by ~1.3%, so we win!  No?

Something we have not discussed is that transistors might be amazingly fast,
and the tiny ones on silicon are even faster.
...But they DO take /SOME/ time to perform their action!

A realistic delay for a transistor (on a consumer "74LS" chip) is 10nS
	10 nano-seconds == 0.000'000'010 seconds

If you put an input in to a BUFFER gate (eg. 74LS07),
	the output will arrive 10nS later

If you had 100 Million of these in a line,
	it would take 1 second to see the answer

When we perform an Add, we load the values straight in to the Adder

When we perform a Subtract, one of the values goes via the Inverters
...and that takes time

When we use a combined Adder/Subtractor
...we ALWAYS load the B input through the Inverters
...But in Adder mode, they have no effect!
...So we have introduced a (needless) delay to every `ADD` instruction

That (50 + 1.3)% saving of transistors means:
	# You can only do HALF the number of operations at any moment in time
	# AND both `add` and `sub` operations will be at the slower `sub` speed!

	Are you worried about speed? ...Then:
		# You will need bespoke/optimised units for each different operation
		# Your design will be more complex
		# There will be more chance of a mistake
		# It will take more time to design
		# The fabrication costs will be higher
		# The chip will use more power, and generate more heat

	Are you worried build cost/complexity? ...Then:
		# Use all the tricks you know to minimise the transistor count
		# [[...the opposite of all the other points above.]]


~-~ How Long? ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~ ~-~   .

I present you the open challenge to work out the delay between:
	start : putting a number on the input pins of a 4-bit "+1" module  [KISS]
	end   : having the final answer present on the output pins

...assume every *transistor* has a propogation delay of 10nS
...remember to consider the Carry.Out bits of every Adder inside it
...does this change if the "+1" module is NOT-Enabled?

So what is your design criteria?

	# More transistors
		= increased manufacturing effort/cost
		= higher design complexity
			= more mistakes
			= more design time
			= higher fabrication costs
		= more heat
		= slower clock speeds
		= faster instructions (eg. `ADD`)

	# Fewer transistors
		= lower manufacturing effort/cost
		= lower design complexity
			= fewer mistakes
			= less design time
			= lower fabrication costs
		= less heat
		= faster clock speeds
		= slower instructions (eg. `ADD`)

Where is the balance between clock-speed and instruction-speed ??
Consider (A) program execution speed
         (B) power consumption & heat dissipation
         (C) manufacturing effort/cost

There is no "one answer fits all" / "right answer"!


~~~~ ,---------------.                                                          .
~~~ (  Where are We?  ) ========================================================.
~~~~ `---------------'                                                          .

In this last section, we have:
	# created a 2's complement box with an Enable switch
		# swapped the NOT gates for XOR gates (aka. NOT-with-enable)
		# started using the +1 box with an Enable pin (we designed earlier)

	# Threw away our Adder
	# Used the new 2's "Enable" pin to switch between Adder & Subtractor mode

We also looked at some of the more pragmatic chip-design issues such as
	# calculate how many transistors we have used

	# consider how saving a few transistors in the base modules
	  can often affect MASSIVE savings in the long run

	# consider the fact that transistors run at a finite speed
	  and some transistor savings may lead to longer paths for some operations

	# considered: multiple adders, means parallel maths operations


~~~~ ,---------------------.                                                    .
~~~ (  A Challenge For you  ) ==================================================.
~~~~ `---------------------'                                                    .

We've now looked at how Negative numbers work
	qv. "Counting Circle (with negative numbers)"

And we created an Adder which only does "+1", ie. the `INC` instruction

Now,   create  an Adder which only does "-1", ie. the `DEC` instruction

Whatever you design has to be valid for this Symbol:

(o) 4-bit (A-1) module                                                          .
!                                                                               .
!	     |                                                                      .
!	  ,--M--.                                                                   .
!	  !  A-1|       <-- outputs A-1                                             .
!	--<C 4 e<--     <-- 4 bit bus                                               .
!	  !  S  |                                                                   .
!	  `--M--'                                                                   .
!	     |                                                                      .
!                                                                               .

Do not worry about optimising it.
Just prove to yourself that you can repeat the steps of creating the "+1" module
...when all the 1's and 0's are swapped over!


~~~~ ,-------------------.                                                      .
~~~ (  Is That The Time?  ) ====================================================.
~~~~ `-------------------'                                                      .

We could keep going, making up more and more maths instructions, or we can
look at other things.

At some point we are going to need a Clock               <~foreshadowing~>
...Something to keep all our little modules in synch

Clock design is an art in and of itself,
  and MANY different strategies exist.

We just want a simple example, so we can say "we can make one from transistors"

We just discussed how it takes (a small amount of) time for
an input to go through the transistor and reach the output.
...This is caled the "Propogation Delay"
...We agreed 10nS was a good balance of "realistic" -vs- "easy to work with"

We know we can make a NOT gate from a single transistor,
so we know our NOT gate has a propogation time of 10nS

Take a look at this
What do you think the we will see on the oscilloscope screen?

(o) Ring Oscillator                                                             .
!                                                                               .
!                .---------------.                                              .
!                | * |   _       |                 =================            .
!                | @ | ,' `.   ; |                  PLACE YOUR BETS             .
!            .---+-@ |      `-'  |                 =================            .
!            |   `---------------'                                              .
!            |                                                                  .
!            |                           :10nS :10nS :10nS :10nS :10nS :10nS :  .
!      ,-----x---------------.           :     :     :     :     :     :     :  .
!      |     Z'              |               __    __    __    __    __    __   .
!      |                     |       [1]  __|  |__|  |__|  |__|  |__|  |__|  |__.
!      |Z'               ____|____                                              .
!     (_)                \   X   /                                              .
!     / \                 \     /        :<-- 20nS ->:<-- 20nS ->:<-- 20nS ->:  .
!    /   \                 \   /                _____       _____       _____   .
!   /     \                 \_/      [2]  _____|     |_____|     |_____|     |__.
!  /___Z___\                (_)                                                 .
!      |                     |X'                                                .
!      |                     |           :<----- 30nS ---->:<----- 30nS ---->:  .
!      |            .'|      |                              _________________   .
!      |     Y'_  ,'  |      |       [3]  _________________|                 |__.
!      `------(_)'   Y|------'                                                  .
!    Y'          `.   |       X'                                                .
!                  `. |              [4]  <other, please specify>               .
!                    `|                                                         .
!                                                                               .

We have three NOT gates
...The Output of  X (X')     goes    to the Input of  Y
   The Output of  Y (Y')     goes    to the Input of  Z
   The Output of  Z (Z')  loops back to the Input of  X

   We have an oscilloscope lead connected to the wire between {Z'} and {X}

It is very difficult to explain how this starts up.
And simulating it is so difficult, that very few simulators are capable of it
	(sadly, falstad.com is NOT one of them)

It's all to do with environmental (mostly "thermal") noise.
...The transistors act as "high-gain amplifiers",
   and quickly amplify the tiniest bits of (eg. thermal) noise
   until ONE of them is the first to generate a viable "1".

At the point in time we have a "1" on ONE of the gates,
  this signal starts to propagate around the circle

And, because we have an ODD number of NOT gates,
  the circuit begins to "RING"

It is known as a "Ring Oscillator"
...and the signal it generates looks like this:

NB. We will continue to assume the propagation delay of our transistors is 10nS

So, in simple/digital terms, every 10nS there will be a state change
...on EVERY transistor Output - at the same time

So no matter where you put you oscilloscope probe, you will see the same shape
Some will be {high} when others are {low}, but it will be the same shape.

Welcome to your first "Timing Diagram":

(o) Ring Oscillator - Timing Diagam                                             .
!                                                                               .
!     :<10nS>:<10nS>:<10nS>:<10nS>:<10nS>:       ---------------------          .
!     :      :      :      :      :      :        DID YOU BET ON #2 ?           .
!     '      '      '      '      '      '       ---------------------          .
!             ______        ______                                              .
!     :      |      |      |      |      :                                      .
!     :      |      |      |      |      :                                      .
!     :      |      |      |      |      :                                      .
!     :______|      | _____|      |______:                                      .
!                                                                               .
!     .      .      .      .      .      .                                      .
!     :      :      :      :      :      :                                      .
!                                                                               .

In reality:
	# Noise-free levels
	# Square corners
	# Instant transitions
...are simply "impossible"	

It would actually look a look a lot more like this:

(o) Ring Oscillator - Timing Diagam - Oscilloscope                              .
!                                                                               .
!     :<10nS>:<10nS>:<10nS>:<10nS>:<10nS>:                                      .
!     :      :      :      :      :      :                                      .
!     :      :      :      :      :      :                                      .
!                                                                               .
!             '~~~~~'       ;~~~~~;                                             .
!     :       |     |       |     |      :                                      .
!     :       |     |       |     |      :                                      .
!     :      |       |     |       |     :                                      .
!     :      |       |     |       |     :                                      .
!     :~~~~~~;       ;~~~~~;       ;~~~~~:                                      .
!                                                                               .
!     .      .      .      .      .      .                                      .
!     :      :      :      :      :      :                                      .
!                                                                               .

In documentaion, it is just easier to draw square corners.

We can see a full {high/low} cycle takes 20nS,  aka 0.000'000'020 seconds
So the "Clock Speed" is

	1 / 0.000'000'020  ==  50'000'000 Hz  ==  50 MHz  (50M times per second)

Let's make a symbol for it

(o) Oscillator - Symbol                                                         .
!                                                                               .
!		,-------.                                                               .
!		|    _  |                                                               .
!		| |_| | >--- Clk                                                        .
!		|       |                                                               .
!		| 50MHz |                                                               .
!		`-------'                                                               .
!                                                                               .

It's not the greatest clock in the world.
	If the chip gets hot,
		it will likely change speed
	If the voltage fluctuates a little
		it will lose its nice even spacing on the clock edges

But it is a working clock,
	that we have built,
		using three transistors !!


~~~~ ,-----------------------------------------------------.                    .
~~~ (  You can't have everything! Where would you keep it?  ) ==================.
~~~~ `-----------------------------------------------------'                    .

So far we can do a few basic types of math (Increment, 2's, Add, Subtract)
...Did you make a Decrementor? (ie. `DEC X`, "-1" module?)

But where will we store these results?
We need some memory...

There are basically TWO types of memory (relevant here)
	SRAM - (Static)  made from transistors
	DRAM - (Dynamic) made from transistors and capacitors

We're not playing with capacitors, so we will choose:  SRAM

~-~~ ,-------------.    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    .
~-~ (  Start Small  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~  .
~-~~ `-------------'    `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `    .

Let's start by building a "Latch"

It will hold 1 bit of information ...PERSISTENTLY  (until it loses power)

And it will have two buttons:  SET  and  RESET

If we press   SET the Output will become 1
If we press RESET the Output will become 0

If NEITHER button  is  pressed, it will stay as it is.
If   BOTH  buttons are pressed, [`Houston, we have a problem.` see below]

This can be done with 2 NOR gates (cost: 4 transistors):

(o) NOR pocket reference                                                        .
!                                                                               .
!	    +--._                                               | A | B |   Y   |   .
!	A----\   `-.  _                             _           +----+--+-------+   .
!	      }    ,'(_)---Y      NOR           ---\ `.o___     | 0 | 0 |   0   |   .
!	B----/  _,'                             ---/_,'         | 0 | 1 |  =1=  |   .
!	    +--'                                                | 1 | 0 |  =1=  |   .
!                                                           | 1 | 1 |  =1=  |   .
!                                                                               .
!   if  ((A == 1) || (B == 1))  then  {Y=0}  else  {Y=1}                        .
!                                        ^------------------ NOT                .
!                                                                               .

(o) NOR Latch                                                                   .
!                                                                               .
!                     +--._                                                     .
!           SET -------\   `-.  _                                               .
!                       }    ,'(_)--+--- Out.NOT(StoredValue)                   .
!                  .---/  _,'       |                                           .
!                  |  +--'          |                                           .
!                  |       .--------'                                           .
!                  |       |                                                    .
!                  `-------{--------.                                           .
!                          |        |                                           .
!                  ,-------'        |                                           .
!                  |                |                                           .
!                  |  +--._         |                                           .
!                  `---\   `-.  _   |                                           .
!                       }    ,'(_)--+--- Out.StoredValue                        .
!         RESET -------/  _,'                                                   .
!                     +--'                                                      .
!                                                                               .

As you can see, we also get a free output which is the
	Inverted (NOT) version of the Stored Value

	ie. if Stored Value is 1   NOT(Stored Value) is 0
	    if Stored Value is 0   NOT(Stored Value) is 1

The output of /each/ NOR gate goes to one of the inputs of the /other/ NOR gate
...this loop is the mechanism that "stores" the data

It is much like our Clock ("Ring Oscillator") made out of a loop of NOT gates

In that scenario we used an ODD number of gates in the loop (3)  _   _
  so that the clock would be a nice square(ish) wave shape ... _| |_| |_

This time we have an EVEN number of gates in the loop (2)
  so the value will NOT "ring"

Have a play...
https://falstad.com/circuit/circuitjs.html?ctz=CQAgjCAMB0l3BWcMBMcUHYMGZIA4UA2ATmIxAUgoqoQFMBaMMAKDAWxABZsURfahKgKgg+XaKSnSZxCmw7de3QlwpCVaqn1osA7uqpdVh7mEJR9SvtmwWeNwnksGHZ+8q5dnkKwg0i-sJOLqZc5tb8Ib6unhFBUT4sAM78kGq4am6ZohAALgBOAK50KWlZeEaelbkghSV+AWggGM0iMWEmrUYmvuZ83ZotCOImfAAmdABmAIZFADZ5DPN04+CiVDCQrADmw6NqGCHGWpYAHhQYEAhgzhiQ5CMQaihqAMp5APYFqwBqM-MSgAuFgXfzOTB3dJiPAQCyvEAfb5-AHA0H8LjCbBIbB4Cy2Zwvd4AUQAKujeBYbkhMVTbtwxGoAErEt5klgAWRazRO3NoYD4Omgu32-GaR2c7Us-T5YqoGBGcrEIEmswWSxWawgmygsFYXMGIkGmEFutYTPK3BqJqtOqMtA2uoQLAtORyNpyOsx1Dt0GdQA
```
$ 1 0.000005 10.20027730826997 50 5 50 5e-11
153 432 320 560 320 0 2 4.999999999999999 5
153 432 464 560 464 0 2 0 5
w 560 464 560 416 0
w 432 336 432 368 0
w 432 416 432 448 0
w 560 320 560 368 0
w 560 416 432 368 0
w 432 416 560 368 0
s 304 304 432 304 0 1 true
s 304 480 432 480 0 1 true
w 560 320 720 320 0
w 560 464 720 464 0
162 720 464 752 464 2 default-led 1 0 0 0.01
g 752 464 768 464 0 0
x 571 518 707 521 4 24 StoredValue:
x 568 278 704 281 6 24 StoredValue:
x 340 335 386 338 4 24 SET
x 326 515 406 518 4 24 RESET
M 720 464 720 512 2 0.1
g 752 320 768 320 0 0
162 720 320 752 320 2 default-led 1 0 0 0.01
M 720 320 720 272 2 0.1
R 304 480 272 480 0 0 40 5 0 0 0.5
R 304 304 272 304 0 0 40 5 0 0 0.5
```

~-~~ ,---------------------.    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
~-~ (  Sanitise Your Input  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~ .
~-~~ `---------------------'    `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  .

Yep! Even Hardware Engineers need to Sanitise their Input!

If  BOTH  Inputs are set to 1 (at the same time)
    BOTH  Outputs go to 0     (outputs will say "SV=0" and "NOT(SV)=0")

...This is (obviously) an INVALID condition
   ...but so is pressing /both/ buttons
      ...don't do it!

We could add another layer with TWO NEW buttons on it
	One button could be the value we want to store {0, 1}
	The other button could be "Store Now"

So to store the value {1}
	# set the VALUE input button to {1}
	# tap the "Store Now" button briefly

So to store the value {0}
	# set the VALUE input button to {0}
	# tap the "Store Now" button briefly

(o) D-Type Latch - Truth Table                                                  .
!                                                                               .
!    .---------------------------.                                              .
!    |   INPUTS  ||   OUTPUTS    |                                              .
!    | Now | Val ||  SET | RESET |                                              .
!    +-----+-----++--------------+                                              .
!    |  0  |  0  ||   0  |   0   |                                              .
!    |  0  |  1  ||   0  |   0   |                                              .
!    |  1  |  0  ||   0  |  =1=  |    <-- RESET condition                       .
!    |  1  |  1  ||  =1= |   0   |    <-- SET   condition                       .
!    `---------------------------'                                              .
!                                                                               .

If the "Now" button is NOT pressed                        ... press >nothing<
If the "Now" button   IS   pressed and the Val input is 0 ... press RESET
If the "Now" button   IS   pressed and the Val input is 1 ... press   SET

The SET Output is easy ...it's an AND gate:
	if ((Now == 1) && (Val == 1))  then  SET=1

(o) D-Type Latch - SET                                                          .
!                                                                               .
!    .---------------------------.                                              .
!    |   INPUTS  ||   OUTPUTS    |                                              .
!    | Now | Val ||  SET | RESET |                                              .
!    +-----+-----++--------------+                                              .
!    |  0  |  0  ||   0  |   0   |                                              .
!    |  0  |  1  ||   0  |   0   |                                              .
!    |  1  |  0  ||   0  |  =1=  |                                              .
!    |  1  |  1  ||  =1= |   0   |    A AND B   <-- Set condition               .
!    `---------------------------'                                              .
!                                                                               .

The RESET is not so familiar:
	if ((Now == 1) && (Val == 0))  then  RESET=1
or	if ((Now == 1) && (Val != 1))  then  RESET=1

...Inputs can only be {1} or {0}, so these two lines are functionally identical

(o) D-Type Latch - RESET                                                        .
!                                                                               .
!    .-------------------.                                                      .
!    |  A     B  |   Y   |                                                      .
!    | Now | Val | RESET |                                                      .
!    +-----+-----+-------+                                                      .
!    |  0  |  0  |   0   |                                                      .
!    |  0  |  1  |   0   |                                                      .
!    |  1  |  0  |  =1=  |   A AND NOT(B)                                       .
!    |  1  |  1  |   0   |                                                      .
!    `-------------------'                                                      .
!                                                                               .

We have seen this uncommon Gate before!

(o) "A NIMPLY B" pocket reference                                               .
!                                                                               .
!                                   +--{B}--+                                   .
!                        (+)---{A}--+--{Y}--+---(-)                             .
!	       +-----.                                          | A | B |   Y   |   .
!	A------|      \                             __          +----+--+-------+   .
!	     _ |       }---Y    A AND NOT(B)    ---|  \___      | 0 | 0 |   0   |   .
!	B---(_)|      /         A NIMPLY B      --o|__/         | 0 | 1 |   0   |   .
!	       +-----'                                          | 1 | 0 |  =1=  |   .
!                                                           | 1 | 1 |   0   |   .
!   if  ((A == 1) && (B == 0))  then  {Y=1}  else  {Y=0}                        .
!                                                                               .

But we never drew out the switch circuit for it. 
We should probably do that now...

The first thing to remember is that because we limited ourself to {N-MOSFET}s
we don't have access to a simple AND gate
...but we DO have an equivalent circuit made from {NOR} and {NOT} Gates

Given that {X AND Y} == {!X NOR !Y}
	     A    AN D         NOT(B)
	NOT( A )  NOR     NOT( NOT(B) )

{NOT, NOT} just flips the value, and flips it back again, so we can eschew that
..."if you have two inversions, they cancel each other out"
	NOT( A )  NOR  NOT( NOT(B) )
	NOT( A )  NOR  ---  --- B      

Giving us: 
    A NIMPLY B   ==   A AND NOT(B)   ==   NOT(A) NOR B

(o) "A NIMPLY B" - Circuit Diagram                                              .
!                                                                               .
!                       {A}                {B}                                  .
!                        |                  |                                   .
!    ....................|..................|................                   .
!    : A NIMPLY B        |                  |               :                   .
!    :  .................|.............     |               :                   .
!    :  : .-----.        |            :     |               :                   .
!    :  : | NOT |        |            :     |               :                   .
!    :  : '-----'      _---_          :     |               :                   .
!    :  :              |   v          :     |               :                   .
!    :  : [+V]--*--+---'   '----[Gnd] :     |               :                   .
!    :  :          |                  :     |               :                   .
!    :  :..........|..................:     |               :                   .
!    :          !A '________________        |               :                   .
!    :                              |       |               :                   .
!    :             .................|.......|.............  :                   .
!    :             : .-----.        |       |            :  :                   .
!    :             : | NOR |        |       |            :  :                   .
!    :             : '-----'      _---_     |            :  :                   .
!    :             :              |   v     |            :  :                   .
!    :             :          ,---'   '-----}------[Gnd] :  :                   .
!    :             :          |             |            :  :                   .
!    :             : [+V]--*--+           _---_          :  :                   .
!    :             :          |           |   v          :  :                   .
!    :             :          +-----------'   '----[Gnd] :  :                   .
!    :             :          |                          :  :                   .
!    :             :..........|..........................:  :                   .
!    :                        | !A NOR B                    :                   .
!    :........................|.............................:                   .
!                             |                                                 .
!                            {Y}                                                .
!                                                                               .

If you need "B NIMPLY A" at any time - just swap the input labels ;)

In the name of completeness, let's make {A IMPLY B}

(o) "A IMPLY B" pocket reference                                                .
!                                                                               .
!	     _ +--._                                            | A | B |   Y   |   .
!	A---(_)-\   `-.                             _           +----+--+-------+   .
!	         }    ,'---Y    NOT(A) OR B     --o\ `.___      | 0 | 0 |  =1=  |   .
!	B-------/  _,'           A IMPLY B      ---/_,'         | 0 | 1 |  =1=  |   .
!	       +--'                                             | 1 | 0 |   0   |   .
!                                                           | 1 | 1 |  =1=  |   .
!   if  ((A == 0) || (B == 1))  then  {Y=1}  else  {Y=0}                        .
!                                                                               .

The first thing to remember is that because we limited ourself to {N-MOSFET}s
we don't have access to a simple OR gate
...but we DO have an equivalent circuit made from {NAND} and {NOT} Gates

Given that {X OR Y} == {!X NAND !Y}
	     NOT(A)    OR          B
	NOT( NOT(A) )  NAND   NOT( B )

{NOT, NOT} just flips the value, and flips it back again, so we can eschew that
..."if you have two inversions, they cancel each other out"
	     NOT(A)    OR          B
	---  --- A     NAND   NOT( B )

Giving us: 
    A IMPLY B   ==   NOT(A) OR B   ==   A NAND NOT(B)

(o) "A IMPLY B" - Circuit Diagram                                               .
!                                                                               .
!                      {A}                   {B}                                .
!                       |                     |                                 .
!    ...................|.....................|................                 .
!    : A IMPLY B        |                     |               :                 .
!    :                  |    .................|.............  :                 .
!    :                  |    : .-----.        |            :  :                 .
!    :                  |    : | NOT |        |            :  :                 .
!    :                  |    : '-----'      _---_          :  :                 .
!    :                  |    :              |   v          :  :                 .
!    :                  |    : [+V]--*--+---'   '----[Gnd] :  :                 .
!    :                  |    :          |                  :  :                 .
!    :                  |    :..........|..................:  :                 .
!    :                  |        _______|                     :                 .
!    : .................|.......|.............                :                 .
!    : : .------.       |       |            :                :                 .
!    : : | NAND |       |       |            :                :                 .
!    : : '------'     _---_   _---_          :                :                 .
!    : :              |   v   |   v          :                :                 .
!    : : [+V]--*--+---'   '---'   '----[Gnd] :                :                 .
!    : :          |                          :                :                 .
!    : :..........|..........................:                :                 .
!    :            | !A NOR B                                  :                 .
!    :............|...........................................:                 .
!                 |                                                             .
!                {Y}                                                            .
!                                                                               .

If you need "B IMPLY A" at any time - just swap the input labels ;)

~-~~ ,-------------.    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    .
~-~ (  Remember Me  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~  .
~-~~ `-------------'    `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `    .

To recap:
	.---------------------------.
	|   INPUTS  ||   OUTPUTS _  |            _
	|  A  |  B  ||  A&B |  A&B  |   /B  and  B   and  !B  are all
	| NOW | VAL ||  SET | RESET |              standard notations for "NOT(B)"
	+-----+-----++--------------+
	|  0  |  0  ||   0  |   0   |
	|  0  |  1  ||   0  |   0   |
	|  1  |  0  ||   0  |  =1=  |   <-- A AND (NOT B)  ... RESET
	|  1  |  1  ||  =1= |   0   |   <-- A AND B        ... SET
	'---------------------------'

(o) D-Type Latch - Logic Diagram                                                .
!                                                                               .
!	              +-----.                                                       .
!	       ,------|      \      +--._                                           .
!	       |      | Set   }======\   `-.  _                                     .
!	       |   ,--|      /        }    ,'(_)--+--- Out.NOT(StoredValue)         .
!	       |   |  +-----'    .---/  _,'       |                                 .
!	       |   |             |  +--'          |                                 .
!	       |   |             |       .--------'                                 .
!	Now ---{---+             |       |                                          .
!	       |   |             `-------{--------.                                 .
!	Val ---+   |                     |        |                                 .
!	       |   |             ,-------'        |                                 .
!	       |   |             |                |                                 .
!	       |   |             |  +--._         |                                 .
!	       |   |  +-----.     ---\   `-.  _   |                                 .
!	       |   `--|      \        }    ,'(_)--+--- Out.StoredValue              .
!	       |    _ | Reset }======/  _,'                                         .
!	       `---(_)|      /      +--'                                            .
!	              +-----'                                                       .
!                                                                               .

We have just inferred the existence of a "D Type Latch"

The Inputs to a D Type Latch are commonly called:
	D  : Data                                [was  'Value'    ]
	En : Enable                              [was  'Store Now']

The Outputs are:
	Q  : The last value stored {1, 0}        [was:  'Out.StoredValue'     ]
	/Q : The opposite of Q                   [was:  'Out.NOT(StoredValue)']

(o) D-Type Latch - Logic Diagram (Stanrdardised I/O Naming)                     .
!                                                                               .
!               +-----.                                                         .
!        ,------|      \      +--._                                             .
!        |      | Set   }======\   `-.  _        _                              .
!        |   ,--|      /        }    ,'(_)--+--- Q   aka  /Q                    .
!        |   |  +-----'    .---/  _,'       |                                   .
!        |   |             |  +--'          |                                   .
!        |   |             |       .--------'                                   .
!  En ---{---+             |       |                                            .
!        |   |             `-------{--------.                                   .
!   D ---+   |                     |        |                                   .
!        |   |             ,-------'        |                                   .
!        |   |             |                |                                   .
!        |   |             |  +--._         |                                   .
!        |   |  +-----.     ---\   `-.  _   |                                   .
!        |   `--|      \        }    ,'(_)--+--- Q                              .
!        |    _ | Reset }======/  _,'                                           .
!        `---(_)|      /      +--'                                              .
!               +-----'                                                         .
!                                                                               .

Finally, a symbol for it:

(o) D-Type Latch - Symbol                                                       .
!                                                                               .
!	  |    |                                                                    .
!	,-v----v-.                                                                  .
!	| En   D |       E:Enable                    D:Data                         .
!	| _ DL   |       _           DL: D-Type Latch                               .
!	| Q    Q |       Q:NOT(StoredValue)          Q:StoredValue                  .
!	`-v----v-'                                                                  .
!	  |    |                                                                    .
!                                                                               .

We now have 1 bit of memory :)

~-~~ ,---------------------.    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
~-~ (  I can has moar RAM?  ) ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~.
~-~~ `---------------------'    `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  .

If we want to build a 4-bit computer,
  we will need FOUR of these to store a value. 

But ALL FOUR Latches MUST read their data bits AT THE SAME TIME

We achieve this by linking all the ENable pins together.

(o) Four 1-bit D-Type Latches with a common Enable pin (diagram)                .
!                                                                               .
!                           A=1011                                              .
!                   _________/ || \_________                                    .
!          .-------'           ||           `--------.                          .
!          |             .-----'`------.             |                          .
!	       |             |             |             |                          .
!	       |             |             |             |                          .
!	  ,----{--------+----{--------+----{--------+----{--------< Now             .
!	  |    |        |    |        |    |        |    |                          .
!	  |    |        |    |        |    |        |    |                          .
!	,-v----v-.    ,-v----v-.    ,-v----v-.    ,-v----v-.                        .
!	| En   D |    | En   D |    | En   D |    | En   D |                        .
!	| _ DL   |    | _ DL   |    | _ DL   |    | _ DL   |                        .
!	| Q    Q |    | Q    Q |    | Q    Q |    | Q    Q |                        .
!	`-v----v-'    `-v----v-'    `-v----v-'    `-v----v-'                        .
!	  |    |        |    |        |    |        |    |                          .
!                                                                               .

We put whatever 4-bit value we want to store in {A}
...and tap the Now/Enable button

Time to make up another symbol...

(o) Four 1-bit D-Type Latches with a common Enable pin (symbol)                 .
!                                                                               .
!	  |    |                                                                    .
!	,-v----M-.                                                                  .
!	| E    D |                                                                  .
!	| _ DL:4 |                                                                  .
!	| Q    Q |                                                                  .
!	`-M----M-'                                                                  .
!	  |    |                                                                    .
!                                                                               .

If we repeated that, but with 8 D-Type Latches, we could store a BYTE
...which we could use as a {Variable, Register, RAM, ...} on an 8 bit CPU

D-Type Latches are quite expensive
	1 @ AND    -> !A NOR !B  ...     4 transistors
	1 @ NIMPLY               ...     3 transistors
	2 @ NOR                  ... 2 * 2 transistors
...a total of 11 transistors per bit

 8-bit => ( 8 * 11 =  88) transistors
64-bit => (64 * 11 = 704) transistors

...that's PER VALUE / MEMORY-LOCATION
...If you want to store TWO numbers, you can just double that 'cost'!

Now you know why Cache Memory is so small [when compared to DRAM] ;)

So in the equation "Y = A + B" you need
	TWO Input  numbers
	ONE Output storage

An 8-bit Full Adder costs         ( 8 *  14 =   112)
plus the two input values         ( 2 *  88 =   176)
and somewhere to store the output ( 1 *  88 =    88)
                                              -----
                                                376  transistors

A 64-bit adder costs              (64 *  14 =   896)
plus the two input values         ( 2 * 704 =  1408)
and somewhere to store the output ( 1 * 704 =   704)
                                              -----
                                              3,008  transistors

The 6502 CPU [*] had 3,510 transistors in total
You have already worked out EXACTLY how 376 of them were being used !

[*] The 6502 was the Core CPU for:
		# Arcade Machines (centipeded, asteroids, tempest, ...)
		# Home Conoles (NES, Atari Lynx, ...),
		# Home Computers (Apple, PET, BBC, Oric, Commodore 64, ...)
		# Cyberdyne Systems T-800
		# ...








          #########    ##########     ########      ######## 
         ##########    ##########    ##########    ##########
         ##                ##        ##      ##    ##      ##
         ##                ##        ##      ##    ##      ##
         #########         ##        ##      ##    ##########
          #########        ##        ##      ##    ######### 
                 ##        ##        ##      ##    ##        
                 ##        ##        ##      ##    ##        
         ##########        ##        ##########    ##        
         #########         ##         ########     ##        







































~~~~ ,-----------------------.                                                  .
~~~ (  Read Betwen The Lines  ) ================================================.
~~~~ `-----------------------'                                                  .

Let's think about our 4-bit computer.

Remember:
	A 4-bit computer works with 4-bit values ...hence the name
	So memory is made up of 4-bit values
	  ...not the 8-bits we are familiar with
	So each memory cell stores a "NYBBLE", NOT a "BYTE"

Let's say we have just TWO nybbles of memory
	# How do we know which one to read ?
	# What do we even MEAN by the word "read"?

Second question first:
	By "Read Address #X" we mean
	   "Connect the Q Outputs of Memory Cell #X to the Data Bus"

Now the less obvious one.

!	  |    |         |    |                                                                    .
!	,-v----M-.     ,-v----M-.                                                                  .
!	| E    D |     | E    D |                                                                  .
!	| _ DL:4 |     | _ DL:4 |                                                                  .
!	| Q    Q |     | Q    Q |                                                                  .
!	`-M----M-'     `-M----M-'                                                                  .
!	  |    |         |    |                                                                    .
!	  |    |         |    |                                                                    .
!	  |    |         |    |                                                                    .
!	  |    |         |    |                                                                    .
!	  |    |         |    |                                                                    .
!	  |    |         |    |                                                                    .
!	  |    |         |    |                                                                    .
!	  |    |         |    |                                                                    .
!	  |    |         |    |                                                                    .
!	  |    |         |    |                                                                    .
!	  |    |         |    |                                                                    .
!	  |    |         |    |                                                                    .
!	  |    |         |    |                                                                    .




~~~~ ,-----------------.                                                        .
~~~ (  Designing a CPU  ) ======================================================.
~~~~ `-----------------'                                                        .

What do we have?
	# A 4-bit storage box
	# A 4-bit adder/subtractor

And we can wire them up so we can add/subtract two numbers and store the result

Using a bit of common sense, we can simplify

	# Multiplication as:  Addition in a loop
		multiplicand = 3
		multiplier   = 4
		result       = 0
		if (multiplier > multiplicand)  swap(multiplier, multiplicand)
		loop:
			if (multiplier == 0)  goto done
			result     = result + multiplicand
			multiplier = multiplier - 1
			goto loop
		done:

	# Division as:  Subtraction in a loop
		dividend = 15
		divisor  = 4
		result   = 0
		loop:
			if (divisor > dividend)  goto done
			result   = result + 1
			dividend = dividend - divisor
			goto loop
		done
		; result = <integer result>,  dividend = <remainder>

So we can see we will need THREE registers to do the four basic mathematical
operations {+, -, *, /}

I'm not here to teach you how to program, but if you've never seen it before:
You can swap two numbers without any need of a `temp` variable
	function swap(x,y)
		x = x ^ y
		y = y ^ x
		x = x ^ y

Let's build a list of all the things we know how to do:

We will adopt the (sane) syntax of:
	{A}ccumulator  =  {X}  <function>  {Y}
...the notation {r} implies "any" register {A, X, Y}

	`AND   A, X, Y`      ; A = X & Y
	`OR    A, X, Y`      ; A = X | Y
	`XOR   A, X, Y`      ; A = X ^ Y

	`NOT   r`            ; r = Invert(r)

	`NAND  A, X, Y`      ; R = Invert(X & Y)
	`NOR   A, X, Y`      ; R = Invert(X | Y)
	`XNOR  A, X, Y`      ; R = Invert(X ^ Y)

	`ADD   A, X, Y`      ; R = X + Y
	`SUB   A, X, Y`      ; R = X - Y

	`MUL   A, X, Y`      ; R = X * Y   [not implemented in silicon]
	`DIV   A, X, Y`      ; R = X / Y   [not implemented in silicon]

	`SWAP  X, Y`         ; X ^= Y ; Y ^= X ; X ^= Y

	`TWOS  r`            ; r = Invert(r) + 1
	`INC   r`            ; r = r + 1
	`DEC   r`            ; r = r - 1

	`MOV   rD, rS`       ; r.Destination = r.Source

Can we REASONABLY remove any of these?

I honestly can't think of a single CPU with ANY of
the compound "Invert()" functions:
...I guess we've ALWAYS been expected to do it as two operations <shrug>
	`NAND  R, X, Y`  ...  R = X & Y  ; NOT R
	`NOR   R, X, Y`  ...  R = X | Y  ; NOT R
	`XNOR  R, X, Y`  ...  R = X ^ Y  ; NOT R
	`TWOS  r`        ...  r = NOT(r) ; INC r

We've already agreed that to keep things moving, we will implement:
	`MUL   R, X, Y`  ...  as "Addition    in a loop"
	`DIV   R, X, Y`  ...  as "Subtraction in a loop"
	`SWAP  X, Y`     ...  three XORs

What does that leave us with?
	`AND   A, X, Y`      ; R = X & Y
	`OR    A, X, Y`      ; R = X | Y
	`XOR   A, X, Y`      ; R = X ^ Y
	`NOT   r`            ; r = Invert(r)

	`ADD   A, X, Y`      ; R = X + Y
	`SUB   A, X, Y`      ; R = X - Y

	`INC   r`            ; r = r + 1
	`DEC   r`            ; r = r - 1

	`MOV   rD, rS`       ; r.Destination = r.Source

What is missing?
	# We don't have any way to get a value in to a register
	# We don't have any way a module to compare two registers (or do we?)
	# We don't have any concept of "program flow control"/`goto`

Forget the last one
...We'll worry about writing a program AFTER we have built an Instruction Set

How do you get a value in to a register?

(o) Remember this?                                                              .
!                                                                               .
!	  |    M                                                                    .
!	,-v----M-.                                                                  .
!	| En   D |                                                                  .
!	| _ DL:4 |     4 bit D-Type Latch                                           .
!	| Q    Q |                                                                  .
!	`-M----M-'                                                                  .
!	  M    M                                                                    .
!                                                                               .

You literally connect the (4) Data Pins to the physical legs of the chip

These pins are known as "The Data Bus"
...We have a 4 bit CPU, so there will be 4 pins for The Data Bus

!            __    __    __    __     __    __    __    __                      .
!           |\ \  |\ \  |\ \  |\ \   |\ \  |\ \  |\ \  |\ \                     .
!            \\ \  \\ \  \\ \  \\ \   \\ \  \\ \  \\ \  \\ \                    .
!             \\ \  \\ \  \\ \  \\ \   \\ \  \\ \  \\ \  \\ \                   .
!          ___|| |__|| |__|| |__|| |___|| |__|| |__|| |__|| |__                 .
!         |\__|| |__|| |__||_|__||_|___||_|__||_|__||_|__||_|__\                .
!         | |o \|/   \|/   \|/   \|/    \|/   \|/   \|/   \|/  |                .
!         | |   |     |     |     |      |     |     |     |   |                .
!         | |  [+V]                      D3    D2    D1    D0  |                .
!         | ;.                          ====== Data Bus ====== |                .
!         |   ;                                                |                .
!         | ;'                                                 |                .
!         | |                                                  |                .
!         | |                                            [Gnd] |                .
!         | |   |     |     |     |      |     |     |     |   |                .
!          \|__/|\___/|\___/|\___/|\____/|\___/|\___/|\___/|\__|                .
!             || |   | |   | |   | |    | |   | |   | |   | |                   .
!             || |   | |   | |   | |    | |   | |   | |   | |                   .
!             // /  // /  // /  // /   // /  // /  // /  // /                   .
!            // /  // /  // /  // /   // /  // /  // /  // /                    .
!           |/_/  |/_/  |/_/  |/_/   |/_/  |/_/  |/_/  |/_/                     .
!                                                                               .


